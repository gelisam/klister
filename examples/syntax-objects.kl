#lang "prelude.kl"

(import (shift "prelude.kl" 2))
(import (shift "prelude.kl" 1))
(import (shift "define-syntax-rule.kl" 1))
(import (shift "list.kl" 1))
(import (shift "monad.kl" 1))
(import "define-syntax-rule.kl")
(import "io.kl")
(import "list.kl")
(import "monad.kl")


-------------------------- What is a syntax object? ---------------------------

-- Let's start with a related, but simpler concept: an s-expression.
--
-- An s-expression such as (foo (bar "baz" 42) (quux)) is a tree whose leaves
-- are integers, strings, and identifiers:
--
-- (datatype (Syntax-Contents A)
--   (list-contents (List A))
--   (integer-contents Integer)
--   (string-contents String)
--   (identifier-contents String))

(datatype (SExpr)
  (sexpr (Syntax-Contents (SExpr))))

(define example-sexpr
  (sexpr (list-contents
           (list
             (sexpr (identifier-contents "foo"))
             (sexpr (list-contents
                      (list
                        (sexpr (identifier-contents "bar"))
                        (sexpr (string-contents "baz"))
                        (sexpr (integer-contents 42)))))
             (sexpr (list-contents
                      (list
                        (sexpr (identifier-contents "quux")))))))))
(example example-sexpr)

-- That is quite a mouthful! In Racket, (SExpr) is called "datum", and the quote
-- macro can be used to construct the above datum much more succinctly as
-- '(foo (bar "baz" 42) (quux)). Klister also has a quote macro, but it means
-- something slightly different:
--
--  notation for <row> in <col> |       Racket |                    Klister
-- -----------------------------+--------------+---------------------------
--                 List Integer |  '(1 2 3) or | (:: 1 (:: 2 (:: 3 (nil))))
--                              | (list 1 2 3) |            or (list 1 2 3)
--          (SExpr) aka "datum" |   '(foo bar) |          no builtin syntax
-- (Syntax) aka "syntax object" |  #'(foo bar) |                 '(foo bar)
--
-- A syntax object such as '(foo (bar "baz" 42) (quux)) is an s-expression
-- whose nodes are annotated with source locations and some information about
-- which variables are in scope at that location. Here's what (Syntax) would
-- look like if it was defined as a datatype:
--
-- (datatype (Syntax)
--   (mk-syntax
--     (Loc)
--     (ScopeSet)
--     (Syntax-Contents (Syntax))))


------------------------ Manipulating (Syntax) values -------------------------

-- The real (Syntax) type is opaque, so the way to construct and inspect a value
-- of type (Syntax) is via primitive functions and macros, not by calling and
-- pattern-matching on the mk-syntax constructor. Here is one such primitive.

(example
  (the (-> (Syntax) (Syntax-Contents Syntax))
       open-syntax))

-- To go in the opposite direction, the close-syntax primitive combines a (Loc),
-- a (ScopeSet), and a (Syntax-Conents Syntax) into a (Syntax) value. One
-- subtelty is that (Loc), (ScopeSet), and (Syntax) are all the same type; we
-- use the type synonym (Loc) to indicate that a function is only interested in
-- the source location of a (Syntax) value, and similarly for (ScopeSet).

-- type synonyms
(define-syntax-rule (Loc) (Syntax))
(define-syntax-rule (ScopeSet) (Syntax))

(define syntax->loc
  (the (-> (Syntax) (Loc))
       id))
(define syntax->scope
  (the (-> (Syntax) (ScopeSet))
       id))
(define syntax->contents
  (the (-> (Syntax) (Syntax-Contents (Syntax)))
       open-syntax))
(example
  (the (-> (Loc) (ScopeSet) (Syntax-Contents Syntax) Syntax)
       close-syntax))

-- This is the first time we define type synonyms in Klister, so it is a good
-- opportunity to point out that Klister doesn't need a dedicated syntax for
-- defining type synonyms and pattern synonyms. Klister macros can appear inside
-- types and patterns, so a type synonym is just a macro which expands to a
-- type.


-- The two primitives we have seen so far, open-syntax and close-syntax, are
-- sufficient to copy any of (Syntax)'s three fields over the corresponding
-- field of another (Syntax) value.

(defun replace-loc (new-loc stx)
  (close-syntax
    new-loc
    (syntax->scope stx)
    (syntax->contents stx)))

(defun replace-scope (new-scope stx)
  (close-syntax
    (syntax->loc stx)
    new-scope
    (syntax->contents stx)))

(defun replace-contents (new-contents stx)
  (close-syntax
    (syntax->loc stx)
    (syntax->scope stx)
    new-contents))

(define syntax1 'here)
(define syntax2 'there)

(example syntax1)
(example syntax2)
(example (replace-loc (syntax->loc syntax1)
                      syntax2))
(example (replace-scope (syntax->scope syntax1)
                        syntax2))
(example (replace-contents (syntax->contents syntax1)
                           syntax2))

-- Remember to look at "syntax-object.golden" to see the output of the above
-- examples, as the output includes the source location. Notice that the first
-- and third examples have the same location, and that the first and last
-- examples have the same contents, the identifier "here".
--
-- There isn't much to notice in the output of the replace-scope example,
-- because the effect of replacing the ScopeSet is only visible when the Syntax
-- is returned from a macro and interpreted as code which binds or looks up
-- variables.


----------------------- Modifying the scope information -----------------------
(TODO: name this section! it's about use sites seeing multiples scopes.)

Here is an example language which motivates many of the features in Klister's scoping system (which is a simpler version of Racket's scoping system).

(my-language
  (unsafe-definitions
    (data (Pythagorean)
      (Pythagorean Integer Integer Integer)))

  (trustworthy-definitions
    (define-type-synonym Pythagorean Pythagorean)

    (data (Maybe a)
      (Nothing)
      (Just a))

    (defun mk-pythagorean (x y z)
      (case (= (+ (* x x) (* y y)) (* z z))
        [(true)
         (Just (Pythagorean x y a))]
        [(false)
         (Nothing)]))

    (define pythagorean-x
      (lambda-case
        [(Pythagorean x _ _) x]))
    (define pythagorean-y
      (lambda-case
        [(Pythagorean _ y _) y]))
    (define pythagorean-z
      (lambda-case
        [(Pythagorean _ _ z) z])))

  (safe-definitions
    (defun pythagorean->list (p)
      (list (pythagorean-x p) (pythagorean-y p) (pythagorean-y p)

    (define my-pythagorean
      (the (Pythagorean) (mk-pythagorean 3 4 5)))

    (example (pythagorean->list my-pythagorean))))

The idea is that the "unsafe" section defines the internal representation of the library, the "trustworthy" section uses this internal representation to expose an API which guarantees that only valid pythagorean triples are constructed, and finally, the "safe" section uses that API.

In terms of scoping rules, this means that:
1. "safe" code can only see the definitions from the "safe" and "trustworthy" sections.
2. "trustworthy" code can see the definitions from the "safe", "trustworthy", and "unsafe" sections.
3. "unsafe" code can see the definitions from the "safe", "trustworthy", and "unsafe" sections.

We thus want to create three scopes called "safe", "trustworthy", and "unsafe". The primitive which creates a new scope is make-introducer; it creates a scope and returns a function which adds or removes that scope from all the nodes in Syntax tree.

(example
  (the (Macro (-> (ScopeAction) (ScopeSet) (ScopeSet)))
       (make-introducer)))

-- type synonym
(define-macro (ScopeIntroducer)
  (-> (ScopeAction) Syntax Syntax))

(data (SafetyLevels)
  (safety-levels
    (ScopeIntroducer)  -- safe
    (ScopeIntroducer)  -- trustworthy
    (ScopeIntroducer)))  -- unsafe

(defun make-safety-levels ()
  (do macro-monad
    (<- safe (make-introducer))
    (<- trustworthy (make-introducer))
    (<- unsafe (make-introducer))
    (pure (safety-levels safe trustworthy unsafe))))

(defun clear-safety-levels (levels stx)
  (case levels
    [(safety-levels safe trustworthy unsafe)
     (safe (remove)
       (trustworthy (remove)
         (unsafe (remove)
           stx)))]))

When annotating binding sites, the scope annotation is the scope to which the binding is added. When annotating use sites, the scope annotation is the set of scopes which are visible at that use site.

(defun annotate-safe-binding-site (levels stx)
  (case levels
    [(safety-levels safe _ _)
     (safe (add)
       (clear-safety-levels levels stx))]))
(defun annotate-trustworthy-binding-site (levels stx)
  (case levels
    [(safety-levels _ trustworthy _)
     (trustworthy (add)
       (clear-safety-levels levels stx))]))
(defun annotate-unsafe-binding-site (levels stx)
  (case levels
    [(safety-levels _ _ unsafe)
     (unsafe (add)
       (clear-safety-levels levels stx))]))

(defun annotate-safe-use-site (levels stx)
  (case levels
    [(safety-levels safe trustworthy _)
     (safe (add)
       (trustworthy (add) stx))]))
(defun annotate-trustworthy-use-site (levels stx)
  (case levels
    [(safety-levels safe trustworthy unsafe)
     (safe (add)
       (trustworthy (add)
         (unsafe (add) stx)))]))
(defun annotate-unsafe-use-site (levels stx)
  (case levels
    [(safety-levels safe trustworthy unsafe)
     (safe (add)
       (trustworthy (add)
         (unsafe (add) stx)))]))

Thus, the mk-pythagorean identifier in (defun mk-pythagorean ...) should be given the scope set {trustworthy}, while the mk-pythagorean identifier in (mk-pythagorean 3 4 5) should be given the scope {safe, trustworthy}.

-- TODO: ideally, the my-language macro would create the (SafetyLevels) value, safe-definitions would call annotate-safe-use-site on its body, and

once syntax parameters are supported, use that to share the SafetyLevels value with defun and friends, so we don't have to traverse the code ourselves, and so that the user can define their own macros around defun and friends.
(defun annotate-safety-levels (stx)
  (case (open-syntax stx)
    [(list-contents (list my-language?(


----------------------- Modifying the scope information2-----------------------
(TODO: name this section! it's about binding sites having multiples scopes.)

Another scoping subtelty is that this language does not follow Klister's convention of using lowercase names for data constructors, and instead follows Haskell's convention of using uppercase names. In particular, for product types like Pythagorean, the data constructor is also named Pythagorean. This language thus needs separate namespaces for types and for values.

In terms of scoping rules, this means that:
1. Type expressions can only see Type definitions.
2. Value expressions can only see Value definitions.

We thus also want to create two scopes called "type" and "value".

(data (Namespaces)
  (namespaces
    (ScopeIntroducer)  -- type
    (ScopeIntroducer)))  -- value

(defun make-namespaces ()
  (do macro-monad
    (<- type (make-introducer))
    (<- value (make-introducer))
    (pure (namespaces type value))))

(defun clear-namespaces (ns stx)
  (case ns
    [(namespaces type value)
     (type (remove)
       (value (remove)
         stx))]))

(defun annotate-type (ns stx)
  (case ns
    [(namespaces type _)
     (type (add)
       (clear-namespace ns stx))]))
(defun annotate-value (ns stx)
  (case ns
    [(namespaces _ value)
     (value (add)
       (clear-namespace ns stx))]))

TODO

These two sets of scoping rules interact: we have safe types, safe values, trustworthy types,  trustworthy values,  unsafe types, and unsafe values. This explains why Klister supports attaching a _set_ of scopes to a bound variable: the mk-pythagorean binding site, for example, has the scope set {trustworthy, value}.

The semantics of this set is that this bound variable is only visible to use sites which can see _both_ of those scopes. For example, a use site with the scope set {safe, trustworthy, value} can see both of those scopes (and can also see the "safe" scope). This same use site can also see

That's for binding sites, but what about use sites? The use site of mk-pythagorean which is inside the safe-definitions section, for example, should look at both the bound variables with {trustworthy, value} and those with {safe, value}. The way to express this is in Klister is by attaching the set {trustworthy, safe, value} to the use site.

Todo: explain why non-variables have scopes.

, so there are 6 kinds of definitions (ST, SV, WT, WT, UT, UV). There are also 6 kinds of variable uses, each of which can view a subset of those 6 kinds of definitions. Oh my!

    | Type (T) | Value (V)
safe (S) | ST, WT | SV, WV
trustworthy (W) | ST, WT, UT | SV, WV, UV
unsafe (U) | ST, WT, UT | SV, WV, UV

To make things



Here are the scoping rules we need:
1. Each definition binds a name which belongs to the intersection of two namespaces


safe/trustworthy/unsafe

combined ScopeSets at use sites (safe can use safe and trustworthy), combined use at definition site (type constructor in unsafe fragment is both unsafe and a type).

add: adding the relevant scopes to all use sites
remove: replace-loc works for the first of set-safety-scopes or set-namespace, but not the second (as that would override the first). Thus, remove is useful to keep concerns separate.


TODO

examples with two non-overlapping marks: lisp-2, separate namespace for types and data constructors.


----------------------- Modifying the scope information3-----------------------
(TODO: name this section! it's about flipping scopes.)


examples with toggle: explain define-macro, write helper functions with similar semantics.

example with overlapping marks: magic-hash, define-unsafe

example with remove: define-safe
