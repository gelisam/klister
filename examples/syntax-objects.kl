#lang "prelude.kl"

(import (shift "prelude.kl" 2))
(import (shift "prelude.kl" 1))
(import (shift "define-syntax-rule.kl" 1))
(import (shift "list.kl" 1))
(import "define-syntax-rule.kl")
(import "io.kl")
(import "list.kl")
(import "monad.kl")


-------------------------- What is a syntax object? ---------------------------

-- Let's start with a related, but simpler concept: an s-expression.
--
-- An s-expression such as (foo (bar "baz" 42) (quux)) is a tree whose leaves
-- are integers, strings, and identifiers:
--
-- (datatype (Syntax-Contents A)
--   (list-contents (List A))
--   (integer-contents Integer)
--   (string-contents String)
--   (identifier-contents String))

(datatype (SExpr)
  (sexpr (Syntax-Contents (SExpr))))

(define example-sexpr
  (sexpr (list-contents
           (list
             (sexpr (identifier-contents "foo"))
             (sexpr (list-contents
                      (list
                        (sexpr (identifier-contents "bar"))
                        (sexpr (string-contents "baz"))
                        (sexpr (integer-contents 42)))))
             (sexpr (list-contents
                      (list
                        (sexpr (identifier-contents "quux")))))))))
(example example-sexpr)

-- That is quite a mouthful! This is why Racket, where (SExpr) is called
-- "datum", supports '(foo (bar "baz" 42) (quux)) as a much more succinct
-- notation for constructing lists and datums. This notation is also recognized
-- in Klister, but it means something slightly different:
--
-- notation for <row> in <col> |       Racket |                    Klister
-- ----------------------------+--------------+---------------------------
--                List Integer |  '(1 2 3) or | (:: 1 (:: 2 (:: 3 (nil))))
--                             | (list 1 2 3) |            or (list 1 2 3)
--         (SExpr) aka "datum" |   '(foo bar) |          no builtin syntax
--  Syntax aka "syntax object" |  #'(foo bar) |                 '(foo bar)

-- A syntax object such as '(foo (bar "baz" 42) (quux)) is an s-expression
-- whose nodes are annotated with source locations and some information about
-- which variables are in scope at that location. Here's what Syntax would look
-- like if it was defined as a datatype:
--
-- (datatype (Syntax)
--   (mk-syntax Loc Scope (Syntax-Contents (Syntax))))

-- The real Syntax type is opaque, so the way to construct and inspect a value
-- of type Syntax is via primitive functions and macros, not by calling and
-- pattern-matching on the mk-syntax constructor.
--
-- Also, in reality there are no types called Loc and Scope, they are internal
-- fields which cannot be separated from the Syntax to which they are attached.
-- It is nevertheless useful to define type synonyms Loc and Scope representing
-- a Syntax whose only field we care about is their source location or their
-- scoping information, as there are a few primitive functions which treat
-- Syntax that way.

-- Macro are also expanded when they occur inside types, so in Klister, a type
-- synonym is just another macro.
(define-syntax-rule (Loc) Syntax)
(define-syntax-rule (Scope) Syntax)

(example
  (the (-> Syntax (Syntax-Contents Syntax))
       open-syntax))
(example
  (the (-> (Loc) (Scope) (Syntax-Contents Syntax) Syntax)
       close-syntax))
(example
  (the (Macro (ScopeAction → (Scope → Scope)))
       make-introducer))


--------------------------- Creating syntax objects ---------------------------

-- Klister supports the usual quote and quasiquote macros, with the usual
-- syntactic sugar, except that quasiquote does not yet support
-- unquote-splicing.

(example
  '(foo (bar "baz" 42) (quux)))
(example
  (quote (foo (bar "baz" 42) (quux))))

(example
  (let [stx1 '"baz"]
    (let [stx2 '(quux)]
      `(foo (bar ,stx1 42) ,stx2))))
(example
  (let [stx1 '"baz"]
    (let [stx2 '(quux)]
      (quasiquote (foo (bar (unquote stx1) 42) (unquote stx2))))))

--(example
--  (let [stx '("baz" 42)]
--    `(foo (bar ,@stx) (quux))))
--(example
--  (let [stx '("baz" 42)]
--    (quasiquote (foo (bar (unquote-splicing stx)) (quux)))))

-- There is also a lower-level function, close-syntax, which acts a lot like
-- the mk-syntax constructor in that it allows you to construct a Syntax from
-- its three fields. Since Klister doesn't provide any way to obtain or
-- construct a value of type Loc nor a value of type Scope, close-syntax takes
-- one Syntax from which it to borrow the Loc, one Syntax from which to borrow
-- the Scope, and a (Syntax-Contents Syntax).

(example
  (close-syntax 'here 'here
    (list-contents
      (list
        'foo
        '(bar "baz" 42)
        '(quux)))))

(defun sexpr->syntax (loc scope x)
  (case x
    [(sexpr sc-sexpr)
     (let [sc-syntax
           (fmap syntax-contents-functor
                 (sexpr->syntax loc scope)
                 sc-sexpr)]
       (close-syntax loc scope
         sc-syntax))]))
(example (sexpr->syntax 'here 'here example-sexpr))


------------------------ Modifing the Syntax-Contents -------------------------

-- The open-syntax function extracts the (Syntax-Contents Syntax) field. This
-- strips the annotations from the root of the tree, but the child nodes have
-- type Syntax so they still have their annotations.

-- TODO

(example
  (open-syntax
    '(foo (bar "baz" 42) (quux))))

(defun syntax->sexpr (stx)
  (let [sc-syntax
        (the (Syntax-Contents Syntax)
             (open-syntax stx))]
    (let [sc-sexpr
          (the (Syntax-Contents (SExpr))
               (fmap syntax-contents-functor
                     syntax->sexpr
                     sc-syntax))]
      (sexpr sc-sexpr))))
(example
  (syntax->sexpr
    '(foo (bar "baz" 42) (quux))))


------------------------ Modifying the source location ------------------------

-- The asymmetry between open-syntax and close-syntax means it is not possible
-- to extract the source location, but it is possible to overwrite it.

(defun replace-loc (new-loc stx)
  (close-syntax new-loc stx
    (open-syntax stx)))

(define syntax1 'here)
(define syntax2 'there)

(example syntax1)
(example syntax2)
(example (replace-loc syntax1 syntax2))

-- Remember to look at "syntax-object.golden" to see the output of the above
-- examples, as the output includes the source location. Notice that the first
-- and third examples have the same location.


----------------------- Modifying the scope information -----------------------
-- TODO
-- Let's now look at how to change the scope information.

-- The effect of replacing the Scope is only visible when the Syntax is returned from a macro and interpreted as code which binds and looks up variables.

(define-macros
  (-- (applyIO list
   --   (putStrLn "foo")
   --   (putStrLn "bar")
   --   (putStrLn "baz"))
   -- =>
   -- (do io-monad
   --   (<- x (putStrLn "foo"))
   --   (<- y (putStrLn "bar"))
   --   (<- z (putStrLn "baz"))
   --   (pure-IO (list x y z)))
   [applyIO
    (lambda (stx)
      (case (open-syntax stx)
        [(list-contents (:: _ (:: macro actions)))
         (pure (close-syntax stx stx
                 (list-contents
                   (:: 'applyIO-aux
                     (:: `(,macro)
                       actions)))))]))]
   -- (applyIO-aux
   --   (list x)
   --   (putStrLn "bar")
   --   (putStrLn "baz"))
   -- =>
   -- (do io-monad
   --   (<- y (putStrLn "bar"))
   --   (<- z (putStrLn "baz"))
   --   (pure-IO (list x y z)))
   [applyIO-aux
    (lambda (stx)
      (case (open-syntax stx)
        [(list-contents (:: _ (:: final-expr actions)))
         (case actions
           [(nil)
            (pure `(pure-IO ,final-expr))]
           [(:: action more-actions)
            (pure `(bind-IO ,action
                     (lambda (x)
                       ,(close-syntax stx stx
                          (list-contents
                            (:: 'applyIO-aux
                              (:: (close-syntax final-expr final-expr
                                    (case (open-syntax final-expr)
                                      [(list-contents xs)
                                       (list-contents (snoc xs 'x))]))
                                more-actions)))))))])]))]))

(run
  (bind-IO (applyIO list
             (pure-IO "foo")
             (pure-IO "bar")
             (pure-IO "baz"))
    (lambda (xs)
      (case xs
        [(list x y z)
         (do io-monad
           (putStrLn x)
           (putStrLn y)
           (putStrLn z))]))))

---- (twice-arg (+ 2 2)
----            (list 1 2 3)
----            5 6)
---- =>
---- (let [x (+ 2 2)]
----   (list 1 2 3 x x 5 6))
--(define-macros
--  ([twice-arg
--    (lambda (stx)
--      (case (open-syntax stx)
--        [(list-contents (:: _ (:: arg (:: pre post-list))))
--         (case (open-syntax pre)
--           [(list-contents pre-list)
--            (pure `(let [x ,arg]
--                     ,(close-syntax stx stx
--                        (list-contents
--                          (list-append pre-list
--                            (:: 'x (:: 'x post-list)))))))])]))]))
--
--(example
--  (twice-arg (+ 2 2)
--             (list 1 2 3)
--             5 6))

-- (twice-arg 3 (twice-arg 2 (twice-arg 1 (list)))))
-- =>
-- (let [z 3]
--   (twice-arg 2 (twice-arg 1 (list)) z z))
-- =>
-- (let [z 3]
--   (let [y 2]
--     ((twice-arg 1 (list)) y x z z)))
-- =>
-- (let [z 3]
--   (let [y 2]
--     (let [x 1]
--       (list x x y y z z))))
--(example
--  (twice-arg 3 (twice-arg 2 (twice-arg 1 (list)))))

---- meta makes the definitions it contains available inside example2's body, as opposed to the default of making them available to the code example2 generates.
--(meta
--  (defun replace-scope (new-scope stx)
--    (close-syntax stx new-scope
--      (open-syntax stx))))
--
--(define-syntax-rule (example2 scope1 scope2 scope3)
--  "hello")
--
--(define-syntax-rule (let2 scope1 body)
--  (let1 scope1 here body))
--
--(example (let2 here ignored))


--(define-macro (example2 scope1)
--  (let [scope2 'here]
--    (pure
--      `(let [,(replace-scope scope1 'x) 1]  -- {not-macro, x1}
--         (let [,(replace-scope scope2 'x) 2]  -- {macro, x1, x2}
--           (let [x 3]
--             (list
--               ,(replace-scope scope1 'x)  -- {not-macro, x1{0}, x2{0}}
--               ,(replace-scope scope2 'x)  -- {macro, x1{0}, x2{0}}
--               x)))))))  -- {x1, x2}
--
--(example (example2 there))


---- TODO: In Racket, '(1 2 3) and (list 1 2 3) construct the same value. In Klister,
---- the former has type Syntax while the latter has type (List Integer).
----
---- (Remember to look at "syntax-object.golden" to see the result of the
---- following examples, including their inferred type!)
--
---- Those two expressions are equivalent (except for a detail we will cover in a
---- moment)
--(example '(1 2 3))
--(example
--  (close-syntax 'here 'here
--    (list-contents (list '1 '2 '3))))
--
---- These two expressions are equivalent.
--(example (list 1 2 3))
--(example (:: 1 (:: 2 (:: 3 (nil)))))
--
----
--
--
---- TODO: link to a short example which explains that in
---- Racket, syntax objects are introduced via ``#'(...)``, whereas in Klister
---- they are introduced via ``'(...)``. Also explain that Klister does not have
---- unannotated s-expressions. And the relationship between Syntax and
---- Syntax-Contents.
