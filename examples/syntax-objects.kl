#lang "prelude.kl"

(import (shift "prelude.kl" 2))
(import (shift "prelude.kl" 1))
(import (shift "define-syntax-rule.kl" 1))
(import (shift "list.kl" 1))
(import (shift "monad.kl" 1))
(import "define-syntax-rule.kl")
(import "io.kl")
(import "list.kl")
(import "monad.kl")


-------------------------- What is a syntax object? ---------------------------

-- Let's start with a related, but simpler concept: an s-expression.
--
-- An s-expression such as (foo (bar "baz" 42) (quux)) is a tree whose leaves
-- are integers, strings, and identifiers:
--
-- (datatype (Syntax-Contents A)
--   (list-contents (List A))
--   (integer-contents Integer)
--   (string-contents String)
--   (identifier-contents String))

(datatype (SExpr)
  (sexpr (Syntax-Contents (SExpr))))

(define example-sexpr
  (sexpr (list-contents
           (list
             (sexpr (identifier-contents "foo"))
             (sexpr (list-contents
                      (list
                        (sexpr (identifier-contents "bar"))
                        (sexpr (string-contents "baz"))
                        (sexpr (integer-contents 42)))))
             (sexpr (list-contents
                      (list
                        (sexpr (identifier-contents "quux")))))))))
(example example-sexpr)

-- That is quite a mouthful! This is why Racket, where (SExpr) is called
-- "datum", supports '(foo (bar "baz" 42) (quux)) as a much more succinct
-- notation for constructing lists and datums. This notation is also recognized
-- in Klister, but it means something slightly different:
--
-- notation for <row> in <col> |       Racket |                    Klister
-- ----------------------------+--------------+---------------------------
--                List Integer |  '(1 2 3) or | (:: 1 (:: 2 (:: 3 (nil))))
--                             | (list 1 2 3) |            or (list 1 2 3)
--         (SExpr) aka "datum" |   '(foo bar) |          no builtin syntax
--  Syntax aka "syntax object" |  #'(foo bar) |                 '(foo bar)
--
-- A syntax object such as '(foo (bar "baz" 42) (quux)) is an s-expression
-- whose nodes are annotated with source locations and some information about
-- which variables are in scope at that location. Here's what Syntax would look
-- like if it was defined as a datatype:
--
-- (datatype (Syntax)
--   (mk-syntax Loc Scope (Syntax-Contents (Syntax))))


------------------------- Manipulating Syntax values --------------------------

-- The real Syntax type is opaque, so the way to construct and inspect a value
-- of type Syntax is via primitive functions and macros, not by calling and
-- pattern-matching on the mk-syntax constructor.
--
-- Also, in reality there are no types called Loc and Scope, they are internal
-- fields which cannot be separated from the Syntax to which they are attached.
-- It is nevertheless useful to define type synonyms Loc and Scope representing
-- a Syntax whose only field we care about is their source location or their
-- scoping information, as there are a few primitive functions which treat
-- Syntax values that way.

-- Macros are also expanded when they occur inside types, so in Klister, a type
-- synonym is just another macro.
(define-syntax-rule (Loc) Syntax)
(define-syntax-rule (Scope) Syntax)

(define syntax->loc id)
(define syntax->scope id)

-- Here are the primitives which use Syntax values that way.

(example
  (the (-> Syntax (Syntax-Contents Syntax))
       open-syntax))
(example
  (the (-> (Loc) (Scope) (Syntax-Contents Syntax) Syntax)
       close-syntax))
(example
  (the (Macro (-> (ScopeAction) (Scope) (Scope)))
       (make-introducer)))

-- The open-syntax and close-syntax primitives are sufficient to set all three
-- fields.

(define syntax->contents open-syntax)

(defun replace-loc (new-loc stx)
  (close-syntax
    new-loc
    (syntax->scope stx)
    (syntax->contents stx)))

(defun replace-scope (new-scope stx)
  (close-syntax
    (syntax->loc stx)
    new-scope
    (syntax->contents stx)))

(defun replace-contents (new-contents stx)
  (close-syntax
    (syntax->loc stx)
    (syntax->scope stx)
    new-contents))

(define syntax1 'here)
(define syntax2 'there)

(example syntax1)
(example syntax2)
(example (replace-loc (syntax->loc syntax1)
                      syntax2))
(example (replace-scope (syntax->scope syntax1)
                        syntax2))
(example (replace-contents (syntax->contents syntax1)
                           syntax2))

-- Remember to look at "syntax-object.golden" to see the output of the above
-- examples, as the output includes the source location. Notice that the first
-- and third examples have the same location, and that the first and last
-- examples have the same contents, the identifier "here".
--
-- There isn't much to notice in the output of the syntax->scope example,
-- because the effect of replacing the Scope is only visible when the Syntax is
-- returned from a macro and interpreted as code which binds or looks up
-- variables.


----------------------- Modifying the scope information -----------------------

-- By default, inner bindings shadow outer bindings of the same identifier.

(define-syntax-rule (example1)
  (let [x 1]
    (let [x 2]
      (let [x 3]
        (list x x x x)))))
(example (example1))

-- The make-introducer Macro action makes it possible to override this default
-- behavior by marking a bound variable in such a way that it becomes invisible
-- to all use sites except those which are also marked.

-- meta is called define-for-syntax in Racket, it makes the definitions it
-- contains available in macro definitions instead of in the code they
-- generate.
(meta
  (define make-mark-applier
    (do macro-monad
      (<- introducer (make-introducer))
      (pure (introducer (add))))))

(define-macro (example2)
  (do macro-monad
    (<- apply-markA make-mark-applier)
    (<- apply-markB make-mark-applier)
    (pure `(let [x 1]
             (let [,(apply-markA 'x) 2]
               (let [,(apply-markB 'x) 3]
                 (list x
                       ,(apply-markA 'x)
                       ,(apply-markB 'x)
                       ,(apply-markA (apply-markB 'x)))))))))
(example (example2))

-- The generated code is still
--
-- (let [x 1]         -- (1)
--   (let [x 2]       -- (2)
--     (let [x 3]     -- (3)
--       (list x      -- (4)
--             x      -- (5)
--             x      -- (6)
--             x))))  -- (7)
--
-- But this time,
-- * The x at (4) doesn't have any marks, so (2) and (3) are invisible to it,
--   and it resolves to (1).
-- * The x at (5) has the A mark, so it sees both (1) and (2), and it resolves
--   to (2).
-- * The x at (6) has the B mark, so it sees both (1) and (3), and it resolves
--   to (3).
-- * The x at (7) has both marks, so it sees all three bindings, and it
--   resolves to (3).

-- TODO

-- First, in order to allow our macros to use syntax->scope, we need to
-- redefine it in a meta-definitions section (meta is called begin-for-syntax
-- in Racket).

(meta
  (define syntax->loc id)
  (define syntax->scope id)
  (define syntax->contents open-syntax)

  (defun replace-scope (new-scope stx)
    (close-syntax
      (syntax->loc stx)
      new-scope
      (syntax->contents stx))))

-- In order to reduce the duplication, those definitions could be placed in a
-- separate module, say "syntax-scope.kl", and imported twice at different phases:
--
-- (import (shift "syntax-scope.kl" 1))
-- (import "syntax-scope.kl")

-- DELETE In order to manipulate the scope information effectively, it is important to
-- DELETE understand the difference between Syntax values which have been written by
-- DELETE the programmer and Syntax values which have been generated by other macros.
-- DELETE Consider the following code:
--
-- DELETE (let [x expr]  -- (1)
-- DELETE   expr))       -- (2)
--
-- DELETE The occurrence of expr at (2) has access to one more variable than the
-- DELETE occurrence at (1), so its Scope is bigger. However, in the following code:
--
-- DELETE (my-macro
-- DELETE   (let [x expr]  -- (3)
-- DELETE     expr))       -- (4)
--
-- DELETE The implementation of my-macro will receive a Syntax in which the two
-- DELETE occurrences of expr, and indeed every node in the tree, are annotated with
-- DELETE the same Scope. This is because a macro can give a completely different
-- DELETE meaning to its input, so that code might not end up binding anything.



-- TODO: get rid of most of those sections
-- DELETE --------------------------- Creating syntax objects ---------------------------
-- DELETE 
-- DELETE -- Klister supports the usual quote and quasiquote macros, with the usual
-- DELETE -- syntactic sugar, except that quasiquote does not yet support
-- DELETE -- unquote-splicing.
-- DELETE 
-- DELETE (example
-- DELETE   '(foo (bar "baz" 42) (quux)))
-- DELETE (example
-- DELETE   (quote (foo (bar "baz" 42) (quux))))
-- DELETE 
-- DELETE (example
-- DELETE   (let [stx1 '"baz"]
-- DELETE     (let [stx2 '(quux)]
-- DELETE       `(foo (bar ,stx1 42) ,stx2))))
-- DELETE (example
-- DELETE   (let [stx1 '"baz"]
-- DELETE     (let [stx2 '(quux)]
-- DELETE       (quasiquote (foo (bar (unquote stx1) 42) (unquote stx2))))))
-- DELETE 
-- DELETE --(example
-- DELETE --  (let [stx '("baz" 42)]
-- DELETE --    `(foo (bar ,@stx)
-- DELETE --          (quux))))
-- DELETE --(example
-- DELETE --  (let [stx '("baz" 42)]
-- DELETE --    (quasiquote (foo (bar (unquote-splicing stx))
-- DELETE --                     (quux)))))
-- DELETE 
-- DELETE -- There is also a lower-level function, close-syntax, which constructs a
-- DELETE -- Syntax from its three fields. That is, it adds an annotation to a leaf or to
-- DELETE -- a list of already-annotated Syntax values.
-- DELETE 
-- DELETE (example
-- DELETE   (close-syntax 'here 'here
-- DELETE     (list-contents
-- DELETE       (list
-- DELETE         'foo
-- DELETE         '(bar "baz" 42)
-- DELETE         '(quux)))))
-- DELETE 
-- DELETE (defun sexpr->syntax (loc scope x)
-- DELETE   (case x
-- DELETE     [(sexpr sc-sexpr)
-- DELETE      (let [sc-syntax
-- DELETE            (the (Syntax-Contents Syntax)
-- DELETE                 (fmap syntax-contents-functor
-- DELETE                       (sexpr->syntax loc scope)
-- DELETE                       sc-sexpr))]
-- DELETE        (close-syntax loc scope
-- DELETE          sc-syntax))]))
-- DELETE (example (sexpr->syntax 'here 'here example-sexpr))
-- DELETE 
-- DELETE 
-- DELETE ------------------------- Matching on syntax objects --------------------------
-- DELETE 
-- DELETE -- The open-syntax function extracts the (Syntax-Contents Syntax) field. This
-- DELETE -- strips the annotations from the root of the tree, but the child nodes have
-- DELETE -- type Syntax so they still have their annotations.
-- DELETE 
-- DELETE (example
-- DELETE   (open-syntax
-- DELETE     '(foo (bar "baz" 42) (quux))))
-- DELETE 
-- DELETE (defun syntax->sexpr (stx)
-- DELETE   (let [sc-syntax
-- DELETE         (the (Syntax-Contents Syntax)
-- DELETE              (open-syntax stx))]
-- DELETE     (let [sc-sexpr
-- DELETE           (the (Syntax-Contents (SExpr))
-- DELETE                (fmap syntax-contents-functor
-- DELETE                      syntax->sexpr
-- DELETE                      sc-syntax))]
-- DELETE       (sexpr sc-sexpr))))
-- DELETE (example
-- DELETE   (syntax->sexpr
-- DELETE     '(foo (bar "baz" 42) (quux))))
-- DELETE 
-- DELETE --  It can also be used as a poor man's
-- DELETE -- unquote-splicing, by appending the lists instead of
-- DELETE (example
-- DELETE   (let [stx '("baz" 42)]
-- DELETE     `(foo ,(close-syntax 'here 'here
-- DELETE              (list-contents
-- DELETE                (case (open-syntax stx)
-- DELETE                  [(list-contents xs)
-- DELETE                   (:: 'bar xs)])))
-- DELETE           (quux))))
-- DELETE 
-- DELETE -- TODO
-- DELETE 
-- DELETE (example
-- DELETE   (open-syntax
-- DELETE     '(foo (bar "baz" 42) (quux))))
-- DELETE 
-- DELETE 
-- DELETE ------------------------ Modifying the source location ------------------------
-- DELETE 
-- DELETE -- The asymmetry between open-syntax and close-syntax means it is not possible
-- DELETE -- to extract the source location, but it is possible to overwrite it.
-- DELETE 
-- DELETE (defun replace-loc (new-loc stx)
-- DELETE   (close-syntax new-loc stx
-- DELETE     (open-syntax stx)))
-- DELETE 
-- DELETE (define syntax1 'here)
-- DELETE (define syntax2 'there)
-- DELETE 
-- DELETE (example syntax1)
-- DELETE (example syntax2)
-- DELETE (example (replace-loc syntax1 syntax2))
-- DELETE 
-- DELETE -- TODO: earlier?
-- DELETE -- Remember to look at "syntax-object.golden" to see the output of the above
-- DELETE -- examples, as the output includes the source location. Notice that the first
-- DELETE -- and third examples have the same location.


----------------------- Modifying the scope information -----------------------
-- TODO
-- Let's now look at how to change the scope information.

-- The effect of replacing the Scope is only visible when the Syntax is returned from a macro and interpreted as code which binds and looks up variables.

--(define-macros
--  (-- (applyIO list
--   --   (putStrLn "foo")
--   --   (putStrLn "bar")
--   --   (putStrLn "baz"))
--   -- =>
--   -- (do io-monad
--   --   (<- x (putStrLn "foo"))
--   --   (<- y (putStrLn "bar"))
--   --   (<- z (putStrLn "baz"))
--   --   (pure-IO (list x y z)))
--   [applyIO
--    (lambda (stx)
--      (case (open-syntax stx)
--        [(list-contents (:: _ (:: macro actions)))
--         (pure (close-syntax stx stx
--                 (list-contents
--                   (:: 'applyIO-aux
--                     (:: `(,macro)
--                       actions)))))]))]
--   -- (applyIO-aux
--   --   (list x)
--   --   (putStrLn "bar")
--   --   (putStrLn "baz"))
--   -- =>
--   -- (do io-monad
--   --   (<- y (putStrLn "bar"))
--   --   (<- z (putStrLn "baz"))
--   --   (pure-IO (list x y z)))
--   [applyIO-aux
--    (lambda (stx)
--      (case (open-syntax stx)
--        [(list-contents (:: _ (:: final-expr actions)))
--         (case actions
--           [(nil)
--            (pure `(pure-IO ,final-expr))]
--           [(:: action more-actions)
--            (pure `(bind-IO ,action
--                     (lambda (x)
--                       ,(close-syntax stx stx
--                          (list-contents
--                            (:: 'applyIO-aux
--                              (:: (close-syntax final-expr final-expr
--                                    (case (open-syntax final-expr)
--                                      [(list-contents xs)
--                                       (list-contents (snoc xs 'x))]))
--                                more-actions)))))))])]))]))
--
--(run
--  (bind-IO (applyIO list
--             (pure-IO "foo")
--             (pure-IO "bar")
--             (pure-IO "baz"))
--    (lambda (xs)
--      (case xs
--        [(list x y z)
--         (do io-monad
--           (putStrLn x)
--           (putStrLn y)
--           (putStrLn z))]))))

---- (twice-arg (+ 2 2)
----            (list 1 2 3)
----            5 6)
---- =>
---- (let [x (+ 2 2)]
----   (list 1 2 3 x x 5 6))
--(define-macros
--  ([twice-arg
--    (lambda (stx)
--      (case (open-syntax stx)
--        [(list-contents (:: _ (:: arg (:: pre post-list))))
--         (case (open-syntax pre)
--           [(list-contents pre-list)
--            (pure `(let [x ,arg]
--                     ,(close-syntax stx stx
--                        (list-contents
--                          (list-append pre-list
--                            (:: 'x (:: 'x post-list)))))))])]))]))
--
--(example
--  (twice-arg (+ 2 2)
--             (list 1 2 3)
--             5 6))

-- (twice-arg 3 (twice-arg 2 (twice-arg 1 (list)))))
-- =>
-- (let [z 3]
--   (twice-arg 2 (twice-arg 1 (list)) z z))
-- =>
-- (let [z 3]
--   (let [y 2]
--     ((twice-arg 1 (list)) y x z z)))
-- =>
-- (let [z 3]
--   (let [y 2]
--     (let [x 1]
--       (list x x y y z z))))
--(example
--  (twice-arg 3 (twice-arg 2 (twice-arg 1 (list)))))

---- meta makes the definitions it contains available inside example2's body, as opposed to the default of making them available to the code example2 generates.
--(meta
--  (defun replace-scope (new-scope stx)
--    (close-syntax stx new-scope
--      (open-syntax stx))))
--
--(define-syntax-rule (example2 scope1 scope2 scope3)
--  "hello")
--
--(define-syntax-rule (let2 scope1 body)
--  (let1 scope1 here body))
--
--(example (let2 here ignored))


--(define-macro (example2 scope1)
--  (let [scope2 'here]
--    (pure
--      `(let [,(replace-scope scope1 'x) 1]  -- {not-macro, x1}
--         (let [,(replace-scope scope2 'x) 2]  -- {macro, x1, x2}
--           (let [x 3]
--             (list
--               ,(replace-scope scope1 'x)  -- {not-macro, x1{0}, x2{0}}
--               ,(replace-scope scope2 'x)  -- {macro, x1{0}, x2{0}}
--               x)))))))  -- {x1, x2}
--
--(example (example2 there))


---- TODO: In Racket, '(1 2 3) and (list 1 2 3) construct the same value. In Klister,
---- the former has type Syntax while the latter has type (List Integer).
----
---- (Remember to look at "syntax-object.golden" to see the result of the
---- following examples, including their inferred type!)
--
---- Those two expressions are equivalent (except for a detail we will cover in a
---- moment)
--(example '(1 2 3))
--(example
--  (close-syntax 'here 'here
--    (list-contents (list '1 '2 '3))))
--
---- These two expressions are equivalent.
--(example (list 1 2 3))
--(example (:: 1 (:: 2 (:: 3 (nil)))))
--
----
--
--
---- TODO: link to a short example which explains that in
---- Racket, syntax objects are introduced via ``#'(...)``, whereas in Klister
---- they are introduced via ``'(...)``. Also explain that Klister does not have
---- unannotated s-expressions. And the relationship between Syntax and
---- Syntax-Contents.
