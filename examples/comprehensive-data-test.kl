#lang "prelude.kl"

-- Test cases for the new data macro

-- ✅ WORKING: Simple type without parameters - bare type name
-- Input:  (data Nat (zero) (suc (Nat)))
-- Transforms to: (datatype (Nat) (zero) (suc (Nat)))
(data Nat
  (zero)
  (suc (Nat)))

-- ✅ WORKING: Type with parameters using existing syntax  
-- Input:  (data (List A) (nil) (cons A (List A)))
-- Transforms to: (datatype (List A) (nil) (cons A (List A)))
(data (List A)
  (nil)
  (cons A (List A)))

-- ✅ WORKING: More complex type
-- Input:  (data (Tree A) (leaf A) (branch (Tree A) (Tree A)))
-- Transforms to: (datatype (Tree A) (leaf A) (branch (Tree A) (Tree A)))
(data (Tree A)
  (leaf A)
  (branch (Tree A) (Tree A)))

-- ✅ WORKING: Type without parameters  
-- Input:  (data Bool (true) (false))
-- Transforms to: (datatype (Bool) (true) (false))
(data Bool
  (true)
  (false))

-- TODO: Constructor args like (suc Nat) instead of (suc (Nat))
-- would require optional-parens wrappers for user-defined types

-- Test construction and pattern matching
(define sample-nat (suc (suc (zero))))
(define sample-list (cons (suc (zero)) (nil)))
(define sample-tree (branch (leaf (zero)) (leaf (suc (zero)))))

(define is-zero 
  (lambda (n)
    (case n
      [(zero) (true)]
      [(suc _) (false)])))

(example sample-nat)
(example (is-zero (zero)))
(example (is-zero sample-nat))

(export Nat zero suc List nil cons Tree leaf branch Bool true false 
        sample-nat sample-list sample-tree is-zero)