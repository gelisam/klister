#lang klister

;; User writes (List A) explicitly because List takes a parameter.
(datatype (List A)
  (nil)
  (:: A (List A)))

(the (List Integer) nil)
(the (List Bool) (:: true (:: false nil)))

;; User writes Nat (single identifier) because Nat takes no parameters.
(datatype Nat
  (zero)
  (suc Nat)) ;; Nat in (suc Nat) refers to the type, will be wrapped by macro.

(the Nat zero)
(the Nat (suc zero))
(the Nat (suc (suc Nat))) ;; Stress test

;; User writes (Maybe A) explicitly.
(datatype (Maybe A)
  (nothing) ;; nothing is nullary, will be wrapped by macro
  (just A)) ;; A is a param, not wrapped by macro

(the (Maybe Bool) (just true))
(the (Maybe Integer) nothing)

;; User writes Tree A (not (Tree A)) - macro handles making (Tree A) for kernel
(datatype Tree A
  (leaf)  ;; leaf is nullary, will be wrapped
  (node (Tree A) A (Tree A))) ;; (Tree A) is already a list, A is param

(the (Tree Integer) (node (leaf) 5 (leaf)))

;; User writes PlainType (single identifier)
(datatype PlainType
  plainCons) ;; plainCons is nullary, will be wrapped

(the PlainType plainCons)

;; User writes MixedParamsType A B SomeOtherType
(datatype MixedParamsType A B SomeOtherType
  (mixedCons A SomeOtherType B)) ;; SomeOtherType is not a param, will be wrapped

(the (MixedParamsType Bool String Integer) (mixedCons true "test" 5))


;; User writes IdWrapper X
(datatype IdWrapper X
  (wrapId X)) ;; X is a param

(the (IdWrapper Nat) (wrapId zero))
(the (IdWrapper (List Bool)) (wrapId (:: true nil)))


;; User writes Foo A B
(datatype Foo A B
  (bar A) ;; A is a param
  (baz B C)) ;; B is a param, C is not a param, will be wrapped

(the (Foo Bool Nat) (bar true))
(the (Foo Bool Nat) (baz false zero)) ;; Assumes C is Nat for this instance

;; User writes (Pair A B) explicitly
(datatype (Pair A B)
  (pair A B))

(the (Pair Nat Bool) (pair zero true))
