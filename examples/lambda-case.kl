#lang "prelude.kl"

(import (shift "prelude.kl" 1))
(import (shift "quasiquote.kl" 1))
(import "list.kl")

-- In Haskell, the LambdaCase language extension allows us to write
--
--     \case
--       [] -> "nil"
--       _:_ -> "cons"
--
-- instead of
--
--     \x -> case x of
--       [] -> "nil"
--       _:_ -> "cons"
--
-- Klister supports macros, meaning you can define this kind of syntactic
-- extensions yourself. Here is how to implement lambda-case as a macro.

(define-macros
  -- (lambda-case                                                   -- (1)
  --   [(nil) "nil"]
  --   [(:: _ _) "cons"])
  -- =>
  -- (lambda (x)                                                    -- (2)
  --   (case x
  --     [(nil) "nil"]
  --     [(:: _ _) "cons"]))
  ([lambda-case
    (lambda (stx)
      (case (open-syntax stx)                                       -- (3)
        [(list-contents (:: _ cases))
         (pure
           `(lambda (x)
              ,(close-syntax stx stx                                -- (4)
                 (list-contents (:: 'case (:: 'x cases))))))]))]))

(example                                                            -- (5)
  (let [f (lambda-case
            [(nil) "nil"]
            [(:: _ _) "cons"])]
    (f (list 1 2 3))))

-- A macro is implemented as a function of type (-> Syntax (Macro Syntax)).
-- Macro is a monad, but we don't make use of its effects in this example, so
-- what matters is that we receive a Syntax and produce a Syntax. In the
-- example at (5), we receive (1) and produce (2).
--
-- Syntax objects will be covered in more details in a different example. For
-- now, it suffices to know that we can split a Syntax into a (List Syntax)
-- using the open-syntax function and matching on the list-contents
-- constructor, as in (3), and we can combine a (List Syntax) back into a
-- Syntax by wrapping the (List Syntax) in that same list-contents constructor
-- and using the close-syntax function, as in (4).
--
-- In our running example, splitting (1) results in the list
--
--     (list 'lambda-case
--           '[(nil) "nil"]
--           '[(:: _ _) "cons"])
--
-- So the pattern (:: _ cases) drops 'lambda-case and keeps the list of cases.
--
-- This list of cases is then used to construct the longer list
--
--     (list 'case
--           'x
--           '[(nil) "nil"]
--           '[(:: _ _) "cons"])
--
-- Which gets combined into
--
--     '(case x
--        [(nil) "nil"]
--        [(:: _ _) "cons"])
--
-- Which gets spliced into a bigger syntax object in order to produce the
-- desired output, (2).
--
-- You can see the result of running the example at (5) by running this file:
--
--     $ cabal run klister -- run examples/lambda-case.kl
--     Example at lambda-case.kl:42.1-97.1:
--       let f = λx. case x of { nil ↦ "nil" ; :: _ _ ↦ "cons" } in
--         (f (:: 1 (:: 2 (:: 3 nil)))) :
--         String ↦
--       "cons"
--
-- Or by looking at the golden file generated by our test suite:
--
--     $ cat examples/lambda-case.golden
--     "cons" : String

(export lambda-case)
