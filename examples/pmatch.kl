#lang "prelude.kl"
(import "defun.kl")
(import "pair-datatype.kl")
(import "list-datatype.kl")

(import (shift "prelude.kl" 1))

(import (shift "identifier.kl" 1))
(import (shift "dot-dot-dot.kl" 1))
(import (shift "defun.kl" 1))
(import (shift "lispy-do.kl" 1))
(import (shift "free-identifier-case.kl" 1))
(import (shift "temporaries.kl" 1))
(import (shift "pair-datatype.kl" 1))
(import (shift "list-datatype.kl" 1))

(meta
  (datatype (Maybe A)
    (nothing)
    (just A)))

(meta
  (defun syntax->list (stx)
    (syntax-case stx ()
      [()
       (pure (nil))]
      [(,x ,xs ...)
       (>>= (syntax->list xs)
         (lambda (list)
           (pure (:: x list))))])))

(meta
  (defun list->syntax (stx-lst stx)
    (case stx-lst
      [(nil) (empty-list-syntax stx)]
      [(:: x xs) (cons-list-syntax x (list->syntax xs stx) stx)])))

(define-macros
  ([pmatch
    (lambda (stx)
      (syntax-case stx ()
        [(_ ,scrut ,pats ...)
         (pure `(let [x ,scrut] (pmatch-aux ,scrut x ,pats ...)))]))]
   [pmatch-aux
    (lambda (stx)
      (syntax-case stx (else)
        [(_ ,scrut ,tgt)
         (pure `(error ',scrut))]
        [(_ ,scrut ,tgt (else ,rhs) ,cs ...)
         (pure rhs)]
        [(_ ,scrut ,tgt ((else ,x) ,rhs) ,cs ...)
         (pure `(let [,x ,tgt]
                  ,rhs))]
        [(_ ,scrut ,tgt (,pat ,rhs) ,cs ...)
         (pure `(let (kf (lambda (_) (pmatch-aux ,scrut ,tgt ,cs ...)))
                  (ppat ,tgt ,pat ,rhs (kf 'hi))))]))]
   [ppat
    (lambda (stx)
      (syntax-case stx ()
        [(_ ,tgt ,x ,ks ,kf)
         (pure (identifier? x))
         (pure `(let [,x ,tgt] ,ks))]
        [(_ ,tgt (,what ,args ...) ,ks ,kf)
         (>>= (syntax->list args)
           (lambda (arg-list)
             (>>= (make-temporaries arg-list)
               (lambda (temps)
                 (let (temp-names (map fst temps))
                   (flet (combine (stxs)
                           (case stxs
                             [(nil) ks]
                             [(:: id-and-stx rest)
                              `(ppat ,(fst id-and-stx) ,(snd id-and-stx) ,(combine rest) ,kf)]))
                      (pure `(case ,tgt
                               [,(cons-list-syntax what (list->syntax temp-names args) args)
                                ,(combine temps)]
                               [(else other) ,kf]))))))))]))]))



(datatype (Nat) (zero) (add1 (Nat)))

(example (pmatch (zero) (else 't)))
(example (pmatch (zero) ((else x) 't)))
(example (pmatch (zero) (x 't)))
(example (pmatch (add1 (zero)) [(add1 (zero)) 't]))
(example (pmatch (add1 (add1 (zero)))
           [(add1 (add1 k)) k]
           [x x]))

(define yep-its-often-zero
   (lambda (num)
     (pmatch num
       [(add1 (add1 k)) k]
       [(add1 k) k]
       [x x])))

(example (yep-its-often-zero (add1 (add1 (zero)))))
(example (yep-its-often-zero (add1 (zero))))
(example (yep-its-often-zero (zero)))
(example (yep-its-often-zero (add1 (add1 (add1 (zero))))))


(defun swap-list (xs)
  (pmatch xs
    [(:: (pair x y) more)
     (:: (pair y x) (swap-list more))]
    [(nil)
     (nil)]))

(example (swap-list (:: (pair 1 '1) (:: (pair 2 '2) (:: (pair 3 '3) (nil))))))

(export pmatch)
