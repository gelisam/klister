#lang "prelude.kl"

-- This file implements the same language as implicit-conversion.kl, but
-- without using type-aware macros. This hopefully helps to demonstrate the
-- benefits of that feature, namely, that we can reuse the host's type checker
-- while adding our own twist to it.

(import "define-syntax-rule.kl")
(import "keyword.kl")
(import (shift "prelude.kl" 1))
(import (shift "bool.kl" 1))
(import (shift "define-syntax-rule.kl" 1))
(import (shift "defuns.kl" 1))
(import (shift "do.kl" 1))
(import (shift "lambda-case.kl" 1))
(import (shift "list.kl" 1))
(import (shift "pair-datatype.kl" 1))
(import (shift "prelude.kl" 2))


-- I can think of two implementation strategies:
--
-- 1. a dynamically-typed interpreter which detects type errors at runtime and
--    inserts the implicit conversion just in time.
-- 2. a statically-typed transpiler which detects type errors at compile-time
--    and produces regular Klister code containing the implicit converstions as
--    ordinary function calls.
--
-- In this file, I will use (2) because it seems closer in spirit to the
-- type-aware macro implementation, which also statically decides which implicit
-- conversion functions to use and then generates code which calls them.

(define-keyword keyword-integer)
(define-keyword keyword-string)
(define-keyword keyword-arrow)
(define-keyword keyword-let-implicit)
(define-keyword keyword-lambda)
(define-keyword keyword-the)

(meta
  -- data Type
  --   = 'Integer
  --   | 'String
  --   | '(-> Integer Integer String)
  (datatype (Type)
    (integer)
    (string)
    (arrow (Type) (Type)))

  (defun type=? (t1 t2)
    (case (pair t1 t2)
      [(pair (integer) (integer))
       true]
      [(pair (string )(string))
       true]
      [(pair (arrow arg1 result1)
             (arrow arg2 result2))
       (and (type=? arg1 arg2)
            (type=? result1 result2))]
      [_
       false]))
  (example
    (the (-> (Type)
             (Type)
             Bool)
         type=?))
  (example
    (type=? (arrow (integer) (string))
            (arrow (integer) (string))))
  (example
    (type=? (arrow (integer) (string))
            (arrow (string) (integer))))

  (defuns
    [type->syntax (loc type)
     (case type
       [(integer)
        'Integer]
       [(string)
        'String]
       [(arrow _ _)
        (close-syntax loc loc
          (list-contents
            (:: '-> (arrow-types->syntaxes loc type))))])]
    [arrow-types->syntaxes (loc types)
     (case types
       [(arrow type more-types)
        (:: (type->syntax loc type)
            (arrow-types->syntaxes loc more-types))]
       [_
        (list (type->syntax loc types))])])
  (example
    (the (-> Syntax
             (Type)
             Syntax)
         type->syntax))
  (example
    (the (-> Syntax
             (Type)
             (List Syntax))
         arrow-types->syntaxes))
  (example
    (type->syntax 'loc (arrow (integer)
                         (arrow (integer)
                           (string)))))
  (example
    (arrow-types->syntaxes 'loc (arrow (integer)
                                  (arrow (integer)
                                    (string)))))

  (define-syntax-rule (Var) Syntax)

  -- data Expr
  --   = 'var
  --   | '42
  --   | '"foo"
  --   | '(let-implicit f body)
  --   | '(lambda ((the String s) (the Integer n) ...) body)
  --   | '(f arg1 arg2 ...)
  (datatype (Expr)
    (expr-var (Var))
    (expr-integer (Integer))
    (expr-string (String))
    (expr-let-implicit (Expr)
                       (Expr))
    (expr-lambda (Pair (Type) (Var))
                 (Expr))
    (expr-app (Expr)
              (Expr)))

  (defuns
    [parse-type (stx)
     (case (open-syntax stx)
       [(identifier-contents _)
        (do (integer? <- (keyword=? stx keyword-integer))
            (string? <- (keyword=? stx keyword-string))
            (if integer?
              (pure (integer))
              (if string?
                (pure (string))
                (syntax-error `(expected integer or string but got ,stx)))))]
       [(list-contents (:: arrow stxs))
        (do (arrow? <- (keyword=? arrow keyword-arrow))
            (if arrow?
              (parse-arrow-type-list stx stxs)
              (syntax-error `(expected (-> ...) but got ,stx))))]
       [_
        (syntax-error `(expected type but got ,stx))])]
    [parse-arrow-type-list (loc stxs)
     (case stxs
       [(nil)
        -- '(->)
        (syntax-error `(expected a list of types but got
                                 ,(close-syntax loc loc (list-contents (:: '-> stxs)))))]
       [(:: result-stx (nil))
        -- '(-> string)
        (parse-type result-stx)]
       [(:: arg-stx rest-stxs)
        -- '(-> integer string)
        (do (arg-type <- (parse-type arg-stx))
            (rest-types <- (parse-arrow-type-list loc rest-stxs))
            (pure (arrow arg-type rest-types)))])])
  (example
    (the (-> Syntax
             (Macro (Type)))
         parse-type))
  (example
    (the (-> Syntax
             (List Syntax)
             (Macro (Type)))
         parse-arrow-type-list))

  (defun parse-var (stx)
    (case (open-syntax stx)
      [(identifier-contents +)
       (pure stx)]
      [_
       (syntax-error `(expected variable name but got ,stx))]))
  (example
    (the (-> Syntax
             (Macro (Var)))
         parse-var))

  (defun parse-the-type-arg (stx)
    (case (open-syntax stx)
      [(list-contents (list the type-stx var-stx))
       (do (the? <- (keyword=? type-stx keyword-the))
           (if the?
             -- (the string s)
             (do (type <- (parse-type type-stx))
                 (var <- (parse-var var-stx))
                 (pure (pair type var)))
             (syntax-error `(expected (the type var) but got ,stx))))]
      [_
       (syntax-error `(expected (the type var) but got ,stx))]))
  (example
    (the (-> Syntax
             (Macro (Pair (Type) (Var))))
         parse-the-type-arg))

  (defun parse-lambda-args (stxs body-expr)
    (case stxs
      [(nil)
       -- '(lambda () body)
       (pure body-expr)]
      [(:: arg-stx rest-stxs)
       (do (arg <- (parse-the-type-arg arg-stx))
           (result-expr <- (parse-lambda-args rest-stxs body-expr))
           (pure (expr-lambda arg result-expr)))]))
  (example
    (the (-> (List Syntax)
             (Expr)
             (Macro (Expr)))
         parse-lambda-args))

  (defun init-last (x0-xs1Z)
    (case x0-xs1Z
      [(pair x0 (nil))
       (pair (nil) x0)]
      [(pair x0 (:: x1 xs2Z))
       (case (init-last (pair x1 xs2Z))
         [(pair xs1Y xZ)
          (pair (:: x0 xs1Y) xZ)])]))
  (example
    (with-unknown-type [A]
      (the (-> (Pair A (List A))
               (Pair (List A) A))
          init-last)))
  (example
    (init-last (pair 1 (list 2 3 4))))

  (defuns
    [parse-expr (stx)
     (case (open-syntax stx)
       [(identifier-contents _)
        -- 'var
        (pure (expr-var stx))]
       [(integer-contents i)
        -- '42
        (pure (expr-integer i))]
       [(string-contents s)
        -- '"foo"
        (pure (expr-string s))]
       [(list-contents (:: head-stx tail-stxs))
        (do (let-implicit? <- (keyword=? head-stx keyword-let-implicit))
            (lambda? <- (keyword=? head-stx keyword-lambda))
            (if let-implicit?
              -- '(let-implicit ...)
              (parse-let-implicit stx tail-stxs)
              (if lambda?
                (parse-lambda stx tail-stxs)
                (parse-app stx head-stx tail-stxs))))]
        [_
         (syntax-error `(expected expression but got ,stx))])]
    [parse-let-implicit (loc stxs)
     -- '(let-implicit ...)
     (case stxs
       [(list f-stx body-stx)
        -- '(let-implicit f body)
        (do (f-expr <- (parse-expr f-stx))
            (body-expr <- (parse-expr body-stx))
            (pure (expr-let-implicit f-expr body-expr)))]
       [_
        (syntax-error `(expected (let-implicit f body) but got ,loc))])]
    [parse-lambda (loc stxs)
     -- '(lambda ...)
     (case stxs
       [(list args-stx body-stx)
        -- '(lambda ... ...)
        (case (open-syntax args-stx)
          [(list-contents arg-stxs)
           -- '(lambda (...) ...)
           (do (body-expr <- (parse-expr body-stx))
               (parse-lambda-args arg-stxs body-expr))]
          [_
            (syntax-error `(expected (lambda (...) ...) but got ,loc))])]
       [_
        (syntax-error `(expected (lambda ... ...) but got ,loc))])]
    [parse-app (loc stx stxs)
     (case (init-last (pair stx stxs))
       [(pair (nil) f-stx)
         -- '(f)
         (parse-expr f-stx)]
       [(pair (:: f-stx more-stxs) last-arg-stx)
         -- '(f more-args ... last-arg)
         (do (f-expr <- (parse-app loc f-stx more-stxs))
             (last-arg-expr <- (parse-expr last-arg-stx))
             (pure (expr-app f-expr last-arg-expr)))])])
  (example
    (the (-> Syntax
             (Macro (Expr)))
         parse-expr))
  (example
    (the (-> Syntax
             (List Syntax)
             (Macro (Expr)))
         parse-let-implicit))
  (example
    (the (-> Syntax
             (List Syntax)
             (Macro (Expr)))
         parse-lambda))
  (example
    (the (-> Syntax
             Syntax
             (List Syntax)
             (Macro (Expr)))
         parse-app))

  (datatype (Explicit-Context-Entry)
    (explicit-context-entry (Var) (Type)))

  (datatype (Implicit-Context-Entry)
    (implicit-context-entry (Type) Syntax))

  (define-syntax-rule (Explicit-Context)
    (List (Explicit-Context-Entry)))

  (define-syntax-rule (Implicit-Context)
    (List (Implicit-Context-Entry)))

  (defun lookup-explicit (key explicit-ctx)
    (case explicit-ctx
      [(nil)
       (pure nothing)]
      [(:: (explicit-context-entry var type) explicit-ctx)
       (do
         (key=? <- (free-identifier=? key var))
         (if key=?
           (pure (just type))
           (lookup-explicit key explicit-ctx)))]))
  (example
    (the (-> Syntax
             (Explicit-Context)
             (Macro (Maybe (Type))))
         lookup-explicit))

  (defun lookup-implicit (key implicit-ctx)
    (case implicit-ctx
      [(nil)
       nothing]
      [(:: (implicit-context-entry type expr) implicit-ctx)
       (if (type=? key type)
         (just expr)
         (lookup-implicit key implicit-ctx))]))
  (example
    (the (-> (Type)
             (Implicit-Context)
             (Maybe Syntax))
         lookup-implicit))

  (define global-explicit-context
    (the (Explicit-Context)
         (list (explicit-context-entry 'integer->string (arrow (integer)
                                                          (string)))
               (explicit-context-entry 'string-append (arrow (string)
                                                        (arrow (string)
                                                          (string))))
               (explicit-context-entry 'string-length (arrow (string)
                                                        (integer)))
               (explicit-context-entry '+ (arrow (integer)
                                            (arrow (integer)
                                              (integer))))
               (explicit-context-entry '* (arrow (integer)
                                            (arrow (integer)
                                              (integer)))))))

  (define global-implicit-context
    (the (Implicit-Context)
         (list)))

  (defuns
    [infer (loc explicit-ctx implicit-ctx expr)
     (case expr
       [(expr-var var-name)
        (>>= (lookup-explicit var-name explicit-ctx)
             (lambda-case
               [(nothing)
                (syntax-error `(,var-name not in scope))]
               [(just var-type)
                (pure (pair var-name var-type))]))]
       [(expr-integer i)
        (pure (pair `(#%integer-literal
                       ,(close-syntax loc loc
                          (integer-contents i)))
                    (integer)))]
       [(expr-string s)
        (pure (pair `(#%string-literal
                       ,(close-syntax loc loc
                          (string-contents s)))
                    (string)))]
       [(expr-let-implicit f-expr body-expr)
        (>>= (infer loc explicit-ctx implicit-ctx f-expr)
             (lambda-case
               [(pair f-stx f-type)
                (infer loc
                       explicit-ctx
                       (:: (implicit-context-entry f-type f-stx)
                           implicit-ctx)
                       body-expr)]))]
       [(expr-lambda (pair arg-type arg-name) body)
        (>>= (infer loc
                    (:: (explicit-context-entry arg-name arg-type)
                        explicit-ctx)
                    implicit-ctx
                    body)
             (lambda-case
               [(pair body-stx body-type)
                (pure (pair `(lambda (,arg-name) ,body-stx)
                            (arrow arg-type body-type)))]))]
       [(expr-app f-expr arg-expr)
        (>>= (infer loc explicit-ctx implicit-ctx f-expr)
             (lambda-case
               [(pair f-stx (arrow arg-type result-type))
                (>>= (check loc explicit-ctx implicit-ctx arg-expr arg-type)
                     (lambda (arg-stx)
                       (pure (pair `(,f-stx ,arg-stx)
                                   result-type))))]))])]
    [check (loc explicit-ctx implicit-ctx expr expected-type)
     (>>= (infer loc explicit-ctx implicit-ctx expr)
          (lambda-case
            [(pair expr-stx actual-type)
             (if (type=? actual-type expected-type)
               (pure expr-stx)
               (case (lookup-implicit (arrow actual-type expected-type) implicit-ctx)
                 [(nothing)
                  (syntax-error `(expected ,(type->syntax loc expected-type)
                                  but got ,(type->syntax loc actual-type)))]
                 [(just conversion-stx)
                  (pure `(,conversion-stx ,expr-stx))]))]))])
  (example (the (-> Syntax
                    (Explicit-Context)
                    (Implicit-Context)
                    (Expr)
                    (Macro (Pair Syntax (Type))))
                infer))
  (example (the (-> Syntax
                    (Explicit-Context)
                    (Implicit-Context)
                    (Expr)
                    (Type)
                    (Macro Syntax))
                check)))

(define-macro (my-example expr-stx)
  (do (expr <- (parse-expr expr-stx))
      (>>= (infer expr-stx global-explicit-context global-implicit-context expr)
        (lambda-case
          [(pair out-stx _)
           (pure `(example ,out-stx))]))))

(export (rename ([my-example example]
                 [keyword-integer Integer]
                 [keyword-string String]
                 [keyword-arrow ->]
                 [keyword-let-implicit let-implicit]
                 [keyword-lambda lambda]
                 [keyword-the the])
                #%module
                my-example
                keyword-integer
                keyword-string
                keyword-arrow
                keyword-let-implicit
                keyword-lambda
                keyword-the
                integer->string
                string-append
                string-length
                +
                *))