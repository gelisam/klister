#lang kernel

(import "defun.kl")
(import "n-ary-app.kl")
(import (shift kernel 1))
(import (shift "n-ary-app.kl" 1))
(import (shift "defun.kl" 1))

(define-macros
  ([unquote
    (lambda (stx)
      (syntax-error (quote "unquote used out of context") stx))]))

-- Re-defining list-append here rather than using the one in "list.kl", in
-- order to avoid a cycle.
--
-- (list-append (list 1 2 3) (list 4 5 6))
-- =>
-- (list 1 2 3 4 5 6)
(defun list-append (xs ys)
  (case xs
    [(nil)
     ys]
    [(:: x xs)
     (:: x (list-append xs ys))]))

(meta
  -- A syntax object representing some code which is itself constructing a
  -- syntax object.
  (datatype (Syntax-Generator)
    (syntax-generator (Syntax)))

  -- A syntax object representing some code which is constructing a list of
  -- syntax objects.
  (datatype (Syntax-List-Generator)
    (syntax-list-generator (Syntax)))

  -- Accessors.
  (defun un-syntax-generator (stx-gen)
    (case stx-gen
      [(syntax-generator stx)
       stx]))
  (defun un-syntax-list-generator (stxs-gen)
    (case stxs-gen
      [(syntax-list-generator stx)
       stx]))
  (example (the (-> (Syntax-Generator)
                    (Syntax))
                un-syntax-generator))
  (example (the (-> (Syntax-List-Generator)
                    (Syntax))
                un-syntax-list-generator))

  -- We need to be careful to attach the right location and scope to the
  -- generated syntax objects, as they will be the syntax objects which will be
  -- returned by the macros which make use of quasiquote. For the generators,
  -- the following will suffice.
  (define generator-loc 'here)
  (define generator-scope 'here)

  -- Produce the code which reconstructs the given syntax object.
  --
  -- (stx->stx-gen '(1 2 3))
  -- =>
  -- (syntax-generator ''(1 2 3))
  --
  -- syntax-generator is here to indicate that the code is generating a syntax
  -- object, and the outer quote is here to indicate that the code it wraps is
  -- a value of type (Syntax), not an expression which still needs to be
  -- evaluated to a value. Once we remove the syntax-generator and quote
  -- wrappers, we see that the code which reconstructs the given syntax object
  -- is simply '(1 2 3). It indeed reconstructs the given syntax object:
  -- 
  -- '(1 2 3)
  -- =>
  -- '(1 2 3)
  --
  -- The following would also have been a valid output:
  --
  -- (define stx '(1 2 3))
  -- (stx->stx-gen stx)
  -- =>
  -- (syntax-generator
  --   '(close-syntax stx stx
  --      (list-contents
  --        (list '1 '2 '3))))
  -- (close-syntax stx stx
  --   (list-contents
  --     (list '1 '2 '3)))
  -- =>
  -- '(1 2 3)
  (defun stx->stx-gen (stx)
    (syntax-generator
      -- `(quote ,stx)
      (close-syntax generator-loc generator-scope
        (list-contents
          (:: 'quote
            (:: stx
              (nil)))))))
  (example (the (-> (Syntax)
                    (Syntax-Generator))
                stx->stx-gen))
)
(define-macros
  -- (example-syntax-generator (stx->stx-gen '(1 2 3)))
  -- =>
  -- (group
  --   (define-macros
  --     ([m
  --       (lambda (stx)
  --         (pure (un-syntax-generator (stx->stx-gen '(1 2 3)))))]))
  --   (example (m)))
  ([example-syntax-generator
    (lambda (stx)
      (case (open-syntax stx)
        [(list-contents (:: _ (:: body (nil))))
         (pure
           (close-syntax stx stx
             -- (group
             --   (define-macros
             --     ([m
             --       (lambda (stx)
             --         (pure (un-syntax-generator (stx->stx-gen '(1 2 3)))))]))
             --   (example (m)))
             (list-contents
               (:: 'group
                 (:: (close-syntax stx stx
                       -- (define-macros
                       --   ([m
                       --     (lambda (stx)
                       --       (pure (un-syntax-generator (stx->stx-gen '(1 2 3)))))]))
                       (list-contents
                         (:: 'define-macros
                           (:: (close-syntax stx stx
                                 -- ([m
                                 --   (lambda (stx)
                                 --     (pure (un-syntax-generator (stx->stx-gen '(1 2 3)))))])
                                 (list-contents
                                   (:: (close-syntax stx stx
                                         -- [m
                                         --  (lambda (stx)
                                         --    (pure (un-syntax-generator (stx->stx-gen '(1 2 3)))))]
                                         (list-contents
                                           (:: 'm
                                             (:: (close-syntax stx stx
                                                   -- (lambda (stx)
                                                   --   (pure (un-syntax-generator (stx->stx-gen '(1 2 3)))))
                                                   (list-contents
                                                     (:: 'lambda
                                                       (:: (close-syntax stx stx
                                                             -- (stx)
                                                             (list-contents
                                                               (:: 'stx
                                                                 (nil))))
                                                         (:: (close-syntax stx stx
                                                               -- (pure (un-syntax-generator (stx->stx-gen '(1 2 3))))
                                                               (list-contents
                                                                 (:: 'pure
                                                                   (:: (close-syntax stx stx
                                                                         -- (un-syntax-generator (stx->stx-gen '(1 2 3)))
                                                                         (list-contents
                                                                           (:: 'un-syntax-generator
                                                                             (:: body
                                                                               (nil)))))
                                                                     (nil)))))
                                                           (nil))))))
                                               (nil)))))
                                     (nil))))
                             (nil)))))
                   (:: (close-syntax stx stx
                         -- (example (m))
                         (list-contents
                           (:: 'example
                             (:: (close-syntax stx stx
                                   -- (m)
                                   (list-contents
                                     (:: 'm
                                       (nil))))
                               (nil)))))
                     (nil)))))))]))]))
(example-syntax-generator (stx->stx-gen '(1 2 3)))
(meta

  (define generator-nil
    (syntax-list-generator '(nil)))
  (example (the (Syntax-List-Generator)
                generator-nil))

  -- A version of :: for syntax generators.
  (defun generator-cons (stx-gen stxs-gen)
    (syntax-list-generator
      -- `(:: ,stx-gen ,stxs-gen)
      (close-syntax generator-loc generator-scope
        (list-contents
          (:: '::
            (:: (un-syntax-generator stx-gen)
              (:: (un-syntax-list-generator stxs-gen)
                (nil))))))))
  (example (the (-> (Syntax-Generator)
                    (Syntax-List-Generator)
                    (Syntax-List-Generator))
                generator-cons))

  -- A version of list-append for syntax generators.
  (defun generator-append (stxs-gen1 stxs-gen2)
    (syntax-list-generator
      -- `(list-append ,stxs-gen1 ,stxs-gen2)
      (close-syntax generator-loc generator-scope
        (list-contents
          (:: 'list-append
            (:: (un-syntax-list-generator stxs-gen1)
              (:: (un-syntax-list-generator stxs-gen2)
                (nil))))))))
  (example (the (-> (Syntax-List-Generator)
                    (Syntax-List-Generator)
                    (Syntax-List-Generator))
                generator-append))

  -- A version of (close-syntax _ _ (list-contents _)) for
  -- syntax generators.
  (defun close-generator (loc scope stxs-gen)
    (syntax-generator
      -- `(close-syntax ,(stx->stx-gen loc) ,(stx->stx-gen scope)
      --    (list-contents ,stxs-gen))
      (close-syntax generator-loc generator-scope
        (list-contents
          (:: 'close-syntax
            (:: (un-syntax-generator (stx->stx-gen loc))
              (:: (un-syntax-generator (stx->stx-gen scope))
                (:: (close-syntax generator-loc generator-scope
                      (list-contents
                        (:: 'list-contents
                          (:: (un-syntax-list-generator stxs-gen)
                            (nil)))))
                  (nil)))))))))
  (example (the (-> (Syntax)
                    (Syntax)
                    (Syntax-List-Generator)
                    (Syntax-Generator))
                close-generator))

  -- Shorthand for the common case of applying a keyword to a single argument.
  (defun generator-keyword (loc scope keyword body)
    (close-generator loc scope
      (generator-cons (stx->stx-gen keyword)
        (generator-cons body
          (generator-nil)))))
  (example (the (-> (Syntax)
                    (Syntax)
                    (Syntax)
                    (Syntax-Generator)
                    (Syntax-Generator))
                generator-keyword))

  -- Turn a generator list into a list generator.
  (defun generator-list (stx-gens)
    (case stx-gens
      [(nil)
       (syntax-list-generator
         -- '(nil)
         '(nil))]
      [(:: stx-gen-head stx-gens-tail)
       (generator-cons
         stx-gen-head
         (generator-list stx-gens-tail))]))
  (example (the (-> (List (Syntax-Generator))
                    (Syntax-List-Generator))
                generator-list))
)
(define-macros
  -- (example-syntax-list-generator (generator-nil))
  -- =>
  -- (example-syntax-generator
  --   (close-generator 'loc 'loc (generator-nil)))
  ([example-syntax-list-generator
    (lambda (stx)
      (case (open-syntax stx)
        [(list-contents (:: _ (:: body (nil))))
         (pure
           (close-syntax stx stx
             -- (example-syntax-generator
             --   (close-generator 'loc 'loc (generator-nil)))
             (list-contents
               (:: 'example-syntax-generator
                 (:: (close-syntax stx stx
                       -- (close-generator 'loc 'loc (generator-nil))
                       (list-contents
                         (:: 'close-generator
                           (:: ''loc
                             (:: ''loc
                               (:: body
                                 (nil)))))))
                   (nil))))))]))]))
(example-syntax-list-generator
  (generator-nil))
(example-syntax-list-generator
  (generator-cons (stx->stx-gen 'hello)
    (generator-cons (stx->stx-gen 'world)
      generator-nil)))
(example-syntax-list-generator
  (generator-append
    (generator-cons (stx->stx-gen 'hello)
      (generator-cons (stx->stx-gen 'world)
        generator-nil))
    (generator-cons (stx->stx-gen 'hello2)
      (generator-cons (stx->stx-gen 'world2)
        generator-nil))))
(example-syntax-generator
  (close-generator 'loc 'scope
    (generator-cons (stx->stx-gen 'hello)
      (generator-cons (stx->stx-gen 'world)
        generator-nil))))
(example-syntax-generator
  (generator-keyword 'loc 'scope 'keyword
    (close-generator 'loc 'scope
      (generator-cons (stx->stx-gen 'hello)
        (generator-cons (stx->stx-gen 'world)
          generator-nil)))))
(example-syntax-list-generator
  (generator-list
    (:: (stx->stx-gen 'hello)
      (:: (stx->stx-gen 'world)
        (nil)))))
(meta

  -- A helper function when extracting the x in (keyword x), after the head has
  -- already been checked to be the expected keyword.
  --
  -- (must-be-singleton-after-keyword
  --   '(my-keyword (1 2 3))
  --   'my-keyword
  --   (list '(1 2 3)))
  -- =>
  -- '(1 2 3)
  --
  -- (must-be-singleton-after-keyword
  --   '(my-keyword 1 2 3)
  --   'my-keyword
  --   (list '1 '2 '3))
  -- =>
  -- error:
  --   (invalid syntax (my-keyword 1 2 3)
  --    did you mean (my-keyword (1 2 3)) ?)
  (defun must-be-singleton-after-keyword (stx stx-keyword stxs)
    (case stxs
      [(:: x (nil))
        -- (keyword x)
        (pure x)]
      [_
       -- (keyword x y z), a common mistake for (keyword (x y z))
       (syntax-error
         -- this is used in the implementation of quasiquote, so we can't just
         -- say `(invalid syntax ,stx did you mean (,stx-keyword (,@stxs)) ?)
         (close-syntax stx stx
           (list-contents
             (:: 'invalid
               (:: 'syntax
                 (:: stx
                   (:: 'did
                     (:: 'you
                       (:: 'mean
                         (:: (close-syntax stx stx
                                (list-contents
                                  (:: stx-keyword
                                    (:: (close-syntax stx stx
                                          (list-contents stxs))
                                      (nil)))))
                               (:: '?
                                 (nil))))))))))))]))

  -- In the absence of unquote, (quasiquote-depth/single 1) behaves the same as
  -- stx->stx-gen, in that the final output is the same as the input. One
  -- difference is that the intermediate code is longer.
  --
  -- (quasiquote-depth/single 1 '(1 2 3))
  -- =>
  -- (generator-cons (stx->stx-gen '1)
  --   (generator-cons (stx->stx-gen '2)
  --     (generator-cons (stx->stx-gen '3)
  --       (generator-nil))))
  -- ...
  -- =>
  -- '(1 2 3)
  --
  -- The intermediate code evaluates each unquoted expression to a syntax
  -- object. The final output uses that syntax object instead of the unquoted
  -- expression.
  --
  -- (define two-three '(2 3))
  -- (quasiquote-depth/single 1 '(1 ,two-three 4)))
  -- =>
  -- (generator-cons (stx->stx-gen '1)
  --   (generator-cons (syntax-generator 'two-three)
  --     (generator-cons (stx->stx-gen '4)
  --       (generator-nil))))
  -- ...
  -- =>
  -- '(1 (2 3) 4)
  --
  -- unquote-spliced is also treated specially. The intermediate code evaluates
  -- each unquote-spliced expression to a list of syntax objects. The final
  -- output uses this list instead of the unquote-spliced expression, with no
  -- parentheses to separate that list from the surrounding elements.
  --
  -- (define two-three (list '2 '3))
  -- (quasiquote-depth/single 1 '(1 ,@two-three 4))
  -- =>
  -- (generator-append
  --   (generator-cons (stx->stx-gen '1)
  --     (generator-nil))
  --   (generator-append
  --     (syntax-list-generator 'two-three)
  --     (generator-cons (stx->stx-gen '4)
  --       (generator-nil))))
  -- ...
  -- =>
  -- '(1 2 3 4)
  --
  -- Nested occurrences of quasiquote are also treated specially. In
  -- (quasiquote-depth/single n), unquote and unquote-spliced are only treated
  -- specially if the number of surrounding quasiquote calls plus n equals the
  -- number of surrounding unquote and unquote-spliced calls, plus 1 for the
  -- unquote or unquote-spliced call in question. The idea is that quasiquote
  -- Q1 might contain some code C1 which itself uses a quasiquote Q2 containing
  -- some code C2. The unquotes which are unbalanced in Q1 are balanced in Q2,
  -- so they will be treated specially when code C1 is executed. The unquotes
  -- which are balanced in Q1 must be treated specially now in order to
  -- fill-in the holes in code C1.
  -- 
  -- (define four '4)
  -- (quasiquote-depth/single 1 '(1 `(2 ,'(3 ,four 5) 6) 7)
  -- =>
  -- (generator-cons (stx->stx-gen '1)
  --   (generator-cons (generator-keyword _ _ 'quasiquote
  --                     (close-generator _ _
  --                       (generator-cons (stx->stx-gen '2)
  --                         (generator-cons (generator-keyword _ _ 'unquote
  --                                           (generator-keyword _ _ 'quote
  --                                             (generator-cons (stx->stx-gen '3)
  --                                               (generator-cons (syntax-generator 'four)
  --                                                 (generator-cons (stx->stx-gen '5)
  --                                                   (generator-nil))))))
  --                           (generator-cons (stx->stx-gen '6)
  --                             (genrator-nil))))))
  --     (generator-cons (stx->stx-gen '7)
  --       (generator-nil))))
  -- ...
  -- =>
  -- '(1 `(2 ,'(3 4 5) 6) 7)
  --
  -- 
  --(error 'undefined)
  ----(if (= depth 0)
  ----  -- the x in `(... ,x ...)
  ----  -- or in `(... `(... ,(... ,x ...) ...) ...)
  ----  (pure stx)
  ----  (case (open-syntax stx)
  ----    [(list-contents (:: stx-head stxs-tail))
  ----     -- (...)
  ----     (>>= (free-identifier=? stx-head 'quasiquote)
  ----       (lambda (quasiquote?)
  ----         (if quasiquote?
  ----           -- (quasiquote x)
  ----           -- or
  ----           -- `x
  ----           (>>= (must-be-singleton-after-keyword stx stx-head stxs-tail)
  ----             (lambda (x)
  ----               (quasiquote-depth/single (+ depth 1) x)))
  ----           (>>= (free-identifier=? stx-head 'unquote)
  ----             (lambda (unquote?)
  ----               (if unquote?
  ----                 -- (unquote x)
  ----                 -- or
  ----                 -- ,x
  ----                 (>>= (must-be-singleton-after-keyword stx stx-head stxs-tail)
  ----                   (lambda (x)
  ----                     (quasiquote-depth (false) (- depth 1) x)))
  ----                 
  ----                 -- some other list, e.g, ((foo ,x bar) ,y baz)
  ----                 (let [stx-tail
  ----                       (close-syntax stx stx
  ----                         (list-contents stxs-tail))]
  ----                   (>>= (quasiquote-depth (false) depth stx-head)
  ----                     (lambda (output-head)
  ----                       (>>= (quasiquote-depth (true) depth stx-tail)
  ----                         (lambda (output-tail)
  ----                           (case (open-syntax output-tail)
  ----                             [(list-contents outputs-tail)
  ----                              (pure (close-syntax stx stx
  ----                                      (list-contents (:: output-head outputs-tail))))]
  ----                             [_
  ----                              (error '"never happens: (quasiquote-depth (true)) always returns a list")]))))))))))))]
  ----    [_
  ----     -- something else, e.g. a string, a number, or an empty list
  ----     (pure (close-syntax stx stx
  ----             (list-contents
  ----               (:: 'quote
  ----                 (:: stx
  ----                   (nil))))))]))
  (defun quasiquote-depth/single/impl (quasiquote-depth/list depth stx)
    (error 'undefined))

  (defun quasiquote-depth/list/impl (quasiquote-depth/single depth stxs)
    (error 'undefined))

  -- Used to fake mutual recursion in the next function.
  (datatype (Args)
    (args/single (Integer) (Syntax))
    (args/list (Integer) (List (Syntax))))

  -- This function fakes mutual recursion. Ideally, we would like two implement
  -- two mutually-recursive functions with different types:
  --
  -- (the (-> (Integer) (Syntax) (Macro (Syntax-Generator)))
  --      quasiquote-depth/single)
  -- (the (-> (Integer) (List Syntax) (Macro (Syntax-List-Generator)))
  --      quasiquote-depth/list)
  --
  -- Instead, they are both implemented as a single function
  --
  -- (the (-> (Args) (Macro (Syntax)))
  --      quasiquote-depth/args)
  --(defun quasiquote-depth/args (args)
  --  -- Recursive calls are made via these correctly-typed wrappers
  --  --
  --  -- (the (-> (Integer) (Syntax) (Macro (Syntax-Generator)))
  --  --      quasiquote-depth/single)
  --  -- (the (-> (Integer) (List Syntax) (Macro (Syntax-List-Generator)))
  --  --      quasiquote-depth/list)
  --  (let [quasiquote-depth/single
  --        (lambda (depth stx)
  --          (>>= (quasiquote-depth/args (args/single depth stx))
  --            (lambda (out)
  --              (pure (syntax-generator out)))))]
  --    (let [quasiquote-depth/list
  --          (lambda (depth stxs)
  --            (>>= (quasiquote-depth/args (args/list depth stxs))
  --              (lambda (out)
  --                (pure (syntax-list-generator out)))))]
  --      -- The implementations also have the correct types
  --      (let [quasiquote-depth/single-impl
  --            (error 'undefined)]
  --        (let [quasiquote-depth/list-impl
  --              (error 'undefined)]
  --          (case args
  --            [(args/single depth stx)
  --             (
  --        --[(args/list depth stxs)
  --        ]
  --        --[(args/list stx depth stxs)
  --        -- -- quasiquote-depth/list reconstructs the list of syntax objects it
  --        -- -- is given as input.
  --        -- --
  --        -- -- (define one '1)
  --        -- -- (define two '2)
  --        -- -- (define three '3)
  --        -- -- (quasiquote-depth/list stx 1 (list one two three))
  --        -- -- =>
  --        -- -- '(close-syntax stx stx
  --        -- --    (list-contents
  --        -- --      (list 'list
  --        -- --            (close-syntax one one
  --        -- --              (list-contents
  --        -- --                (list 'quote '1)))
  --        -- --            (close-syntax two two
  --        -- --              (list-contents
  --        -- --                (list 'quote '2)))
  --        -- --            (close-syntax three three
  --        -- --              (list-contents
  --        -- --                (list 'quote '3))))))
  --        -- -- ...
  --        -- -- =>
  --        -- -- (list '1 '2 '3)
  --        -- --
  --        -- -- It supports the same unquoting logic as in
  --        -- -- quasiquote-depth/single.
  --        -- --
  --        -- -- (define three-four '(3 4))
  --        -- -- (define five-six (list '5 '6))
  --        -- -- (quasiquote-depth/list stx 1
  --        -- --   (list '1 '2 ',three-four ',@five-six '7 '8))
  --        -- -- =>
  --        -- -- ...
  --        -- -- =>
  --        -- -- (list '1 '2 '(3 4) '5 '6 '7 '8)
  --        -- (error '"not implemented")]
  --         )
  --         )))
  --(example (the (-> (Args) (Macro (Syntax)))
  --              quasiquote-depth/args))
  --(defun quasiquote-depth (depth stx)
  --  (quasiquote-depth/args (args/single depth stx)))
)

--(define-macros
--  ([quasiquote
--    (lambda (stx)
--      (case (open-syntax stx)
--        [(list-contents (:: stx-head stxs-tail))
--         -- (quasiquote ...)
--         -- or
--         -- `x
--         (>>= (must-be-singleton-after-keyword stx stx-head stxs-tail)
--           (lambda (x)
--             (quasiquote-depth 1 x)))]
--        [_
--         (syntax-error (quote "quasiquote used out of context") stx)]))]
--   [quasiquote/loc
--    (lambda (stx)
--      (syntax-case stx
--        [(list (_ loc q))
--         (pure
--           (close-syntax stx stx
--             (list-contents
--               (:: 'replace-loc
--                 (:: loc
--                   (:: (close-syntax stx stx
--                         (list-contents
--                           (:: 'quasiquote
--                             (:: q
--                               (nil)))))
--                     (nil)))))))]))]))
--
--(export unquote quasiquote quasiquote/loc)
