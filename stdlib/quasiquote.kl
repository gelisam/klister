#lang kernel

(import (shift kernel 1))
(import (shift "n-ary-app.kl" 1))
(import (shift "defun.kl" 1))

(meta
  -- a helper function when extracting the x in (keyword x), after the head has
  -- already been checked to be the expected keyword
  (defun must-be-singleton-after-keyword (stx stx-keyword stxs)
    (case stxs
      [(:: x (nil))
        -- (keyword x)
        (pure x)]
      [_
       -- (keyword x y z), a common mistake for (keyword (x y z))
       (syntax-error
         -- this is used in the implementation of quasiquote, so we can't just
         -- say `(invalid syntax ,stx did you mean (,stx-keyword (,@stxs)) ?)
         (close-syntax stx stx
           (list-contents
             (:: 'invalid
               (:: 'syntax
                 (:: stx
                   (:: 'did
                     (:: 'you
                       (:: 'mean
                         (:: (close-syntax stx stx
                                (list-contents
                                  (:: stx-keyword
                                    (:: (close-syntax stx stx
                                          (list-contents stxs))
                                      (nil)))))
                               (:: '?
                                 (nil))))))))))))]))

  (defun quasiquote-depth (depth stx is-tail)
    (if (= depth 0)
      -- the x in `(... ,x ...)
      -- or in `(... `(... ,(... ,x ...) ...) ...)
      (pure stx)
      (case (open-syntax stx)
        [(list-contents (:: stx-head stxs-tail))
         -- (...)
         (if is-tail
           (error 'todo)
           (>>= (free-identifier=? stx-head 'quasiquote)
             (lambda (quasiquote?)
               (if quasiquote?
                 -- (quasiquote x)
                 -- or
                 -- `x
                 (>>= (must-be-singleton-after-keyword stx stx-head stxs-tail)
                   (lambda (x)
                     (quasiquote-depth (+ depth 1) x (false))))
                 (>>= (free-identifier=? stx-head 'unquote)
                   (lambda (unquote?)
                     (if unquote?
                       -- (unquote x)
                       -- or
                       -- ,x
                       (>>= (must-be-singleton-after-keyword stx stx-head stxs-tail)
                         (lambda (x)
                           (quasiquote-depth (- depth 1) x (false))))
                       
                       -- some other list, e.g, ((foo ,x bar) ,y baz)
                       (let [stx-tail
                             (close-syntax stx stx
                               (list-contents stxs-tail))]
                         (>>= (quasiquote-depth depth stx-head (false))
                           (lambda (output-head)
                             (>>= (quasiquote-depth depth stx-tail (true))
                               (lambda (output-tail)
                                 (case (open-syntax output-tail)
                                   [(list-contents outputs-tail)
                                    (pure (close-syntax stx stx
                                            (list-contents (:: output-head outputs-tail))))]
                                   [_
                                    (error '"never happens: (quasiquote-depth _ '(...) (true)) always returns a list")])))))))))))))]
        [_
         -- something else, e.g. a string, a number, or an empty list
         (pure stx)])))
)
--(define-macros
--  ([quasiquote
--    (lambda (stx)
--      (quasiquote-depth 0 stx (false)))]))
--
--(define-macros
--  ([quasiquote/loc
--    (lambda (stx)
--      (syntax-case stx
--        [(list (_ loc q))
--         (pure (list-syntax ('replace-loc loc (list-syntax ('quasiquote q) stx)) stx))]))]))
--
--(export unquote quasiquote quasiquote/loc)
