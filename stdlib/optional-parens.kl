#lang kernel

-- Allow e.g. unit instead of (unit)

[import [shift kernel 1]]

(meta
  (define optional-parens
    (lambda (symbol)
      (lambda (stx)
        (case (open-syntax stx)
          [(identifier-contents x)
           (pure (((close-syntax stx) stx) (list-contents (:: symbol (nil)))))]
          [(list-contents (:: _ args))
           (pure (((close-syntax stx) stx) (list-contents (:: symbol args))))])))))

-- TODO: wrap 'datatype' so that parentheses are also optional for
-- the nullary types and constructors it creates
(define-macros
  ([my-Syntax (optional-parens 'Syntax)]
   [my-Integer (optional-parens 'Integer)]
   [my-Macro (optional-parens 'Macro)]
   [my-Type (optional-parens 'Type)]
   [my-String (optional-parens 'String)]
   [my-IO (optional-parens 'IO)]
   [my-ScopeAction (optional-parens 'ScopeAction)]
   [my-flip (optional-parens 'flip)]
   [my-add (optional-parens 'add)]
   [my-remove (optional-parens 'remove)]
   [my-Unit (optional-parens 'Unit)]
   [my-unit (optional-parens 'unit)]
   [my-Bool (optional-parens 'Bool)]
   [my-true (optional-parens 'true)]
   [my-false (optional-parens 'false)]
   [my-Problem (optional-parens 'Problem)]
   [my-module (optional-parens 'module)]
   [my-declaration (optional-parens 'declaration)]
   [my-type (optional-parens 'type)]
   [my-pattern (optional-parens 'pattern)]
   [my-type-pattern (optional-parens 'type-pattern)]
   [my-Maybe (optional-parens 'Maybe)]
   [my-nothing (optional-parens 'nothing)]
   [my-List (optional-parens 'List)]
   [my-nil (optional-parens 'nil)]
   [my-Syntax-Contents (optional-parens 'Syntax-Contents)]
   [my-Output-Port (optional-parens 'Output-Port)]))

(defmacro data-optional-parens . all-args
  (let* ((parse-head-and-constructors
           (lambda (Args)
             (if (empty? Args)
               (error "data-optional-parens: No arguments provided.")
               (if (list? (hd Args))
                 (list (hd Args) (cdr Args)) ; Head is pre-grouped, e.g. ((Maybe A) ...)
                 ; Head is not pre-grouped, collect leading symbols
                 (let Rec ((RemainingArgs Args) (HeadAccumulator []))
                   (if (or (empty? RemainingArgs) (not (symbol? (hd RemainingArgs))))
                     (if (empty? HeadAccumulator)
                       (error "data-optional-parens: Invalid declaration head, expected symbols or a list.")
                       (list (reverse HeadAccumulator) RemainingArgs))
                     (Rec (cdr RemainingArgs) (cons (hd RemainingArgs) HeadAccumulator))))))))

         (parsed-parts (parse-head-and-constructors all-args))
         (head-spec (first parsed-parts)) ; This is (Name P1 P2...) or (Name)
         (constructor-defs-unprocessed (second parsed-parts))

         (processed-head head-spec) ; Head-spec from parser is already what kernel `datatype` expects
         (datatype-params (if (list? head-spec) (cdr head-spec) ())) ; Params are (cdr head-spec)

         (processed-constructor-defs
           (map (lambda (ctor-def)
                  (if (symbol? ctor-def)
                    (list ctor-def) ; Nullary constructor, e.g., nothing -> (nothing)
                    (if (list? ctor-def)
                      (let ((ctor-name (car ctor-def))
                            (ctor-args-unprocessed (cdr ctor-def)))
                        (cons ctor-name ; e.g., just
                              (map (lambda (arg)
                                     (if (symbol? arg)
                                       (if (mem? arg datatype-params)
                                         arg        ; Argument is a type parameter, keep as is
                                         (list arg)) ; Argument is a symbol but not a type param, wrap it
                                       arg))        ; Argument is already a list (e.g., (List Nat)), keep as is
                                   ctor-args-unprocessed)))
                      (error "data-optional-parens: Constructor definition must be a symbol or a list."))))
                constructor-defs-unprocessed)))

    `(datatype ,processed-head ,@processed-constructor-defs)))

(export (rename ([my-Syntax Syntax]
                 [my-Integer Integer]
                 [my-Macro Macro]
                 [my-Type Type]
                 [my-String String]
                 [my-IO IO]
                 [my-ScopeAction ScopeAction] [my-flip flip] [my-add add] [my-remove remove]
                 [my-Unit Unit] [my-unit unit]
                 [my-Bool Bool] [my-true true] [my-false false]
                 [my-Problem Problem] [my-module module] [my-declaration declaration] [my-type type] [my-pattern pattern] [my-type-pattern type-pattern]
                 [my-Maybe Maybe] [my-nothing nothing]
                 [my-List List] [my-nil nil]
                 [my-Syntax-Contents Syntax-Contents]
                 [my-Output-Port Output-Port]
                 [data-optional-parens datatype])
                my-Syntax
                my-Integer
                my-Macro
                my-Type
                my-String
                my-IO
                my-ScopeAction my-flip my-add my-remove
                my-Unit my-unit
                my-Bool my-true my-false
                my-Maybe my-nothing
                my-List my-nil
                my-Syntax-Contents
                my-Output-Port))
