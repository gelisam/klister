#lang kernel

(import "defun.kl")
(import "n-ary-app.kl")
(import "optional-parens.kl")
(import "quasiquote.kl")

(defun id (x) x)
(define const (lambda (x y) x))
(define compose (lambda (f g x) (f (g x))))

-- Macro to support datatype names without parentheses
(meta
  (define data-macro
    (lambda (stx)
      (case (open-syntax stx)
        [(list-contents (:: _ (:: typeNameAndArgs ctorSpecs)))
         (case (open-syntax typeNameAndArgs)
           [(identifier-contents _)
            -- Handle bare type name: (data Nat ctor1 ctor2...)
            -- Transform to: (datatype (Nat) ctor1 ctor2...)
            (pure (close-syntax stx stx
                   (list-contents (:: 'datatype 
                                      (:: (close-syntax typeNameAndArgs typeNameAndArgs
                                           (list-contents (:: typeNameAndArgs (nil))))
                                          ctorSpecs)))))]
           [(list-contents _)
            -- Handle parenthesized type name: (data (List A) ctor1 ctor2...)
            -- Transform to: (datatype (List A) ctor1 ctor2...)
            (pure (close-syntax stx stx
                   (list-contents (:: 'datatype 
                                      (:: typeNameAndArgs ctorSpecs)))))]
           [_ (syntax-error '"bad data syntax" stx)])]
        [_ (syntax-error '"bad data syntax" stx)]))))

(define-macros
  ([data data-macro]))

-- When adding an export to this file, please remember to add a corresponding
-- entry to "examples/primitives-documentation.kl", so that we at least have
-- its type signature as a bare minimum form of documentation.
(export -- primitive module macros
        #%module

        -- primitive declaration macros
        define
        data
        datatype
        define-macros
        example
        run
        import
        export
        meta
        group

        -- primitive types
        Syntax open-syntax close-syntax
        ->
        Integer + - * / abs negate > >= < <= = /= integer->string
        Macro
        Type
        String string-append substring string-length
               string=? string/=? string<? string<=? string>? string>=?
               string-upcase string-downcase string-titlecase string-foldcase
        IO pure-IO bind-IO

        -- primitive datatypes
        ScopeAction flip add remove
        Unit unit
        Bool true false
        Problem module declaration type expression pattern type-pattern
        Maybe nothing just
        List nil ::
        Syntax-Contents list-contents integer-contents string-contents identifier-contents

        -- primitive expression macros
        error
        the
        let
        flet
        lambda
        #%app
        #%integer-literal
        #%string-literal
        pure
        >>=
        syntax-error
        bound-identifier=?
        free-identifier=?
        quote
        ident-syntax
        empty-list-syntax
        cons-list-syntax
        list-syntax
        integer-syntax
        string-syntax
        replace-loc
        syntax-case
        let-syntax
        log
        make-introducer
        which-problem
        case
        type-case

        -- primitive patterns
        else

        -- primitive universal macros
        with-unknown-type

        -- non-primitive declaration macros
        defun

        -- non-primitive expression macros
        unquote
        quasiquote
        quasiquote/loc

        -- non-primitive expressions
        if
        id
        const
        compose
        
        -- IO primitives
        Output-Port
        stdout
        write)
